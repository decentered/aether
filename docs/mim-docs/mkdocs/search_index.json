{
    "docs": [
        {
            "location": "/", 
            "text": "Mim Protocol v0.1\n\n\nMim is a distributed, peer-to-peer network protocol that distributes text. It's the protocol underlying Aether, which is the reference implementation of the Mim protocol.\n\n\nMim, at a very basic level, can be likened to a more decentralised Usenet where everyone is their own Usenet server. Building on that base platform, Mim adds modern features we've come to expect from our tools of communication.\n\n\nFeatures\n\n\nMim provides, in a peer-to-peer fashion:\n\n\n\n\nThe ability to freely create boards, threads and posts within them\n\n\nUpvoting, downvoting posts and thus provide community moderation\n\n\nAdmin-moderating the communities you have created,\n\n\nBut also the right for your communities to reject your moderation\n\n\nAdd and remove moderators for admins\n\n\nAnd also the ability to have unmoderated communities that rely completely on community moderation\n\n\nSpam and sybil protection with proof-of-work, blocking and a reputation system\n\n\nUnique identities and usernames with cryptographic signatures (optional)\n\n\nOn the other side, posting without a signature, thus remaining anonymous\n\n\nAn extensible protocol that can accommodate new object types, and proper structure to declare extensions.\n\n\nIn addition, it provides static nodes, which are static websites that can be used as containers of information available for everyone\n\n\n\n\nMim does not require need infrastructure, and is completely independent of anything except a working Internet connection. Nodes bootstrap off of each other when they join the network. The only thing you need to know is an IP and a Port that is a Mim node. In most practical cases, Mim client applications come with their own bootstrap nodes.\n\n\nPhilosophy\n\n\nThe aim of the author is to create an underlying common-language between computers for human discussion that is ubiquitous and free.\n\n\n\"Mim\" name is a reference to \nmime\n, the \ntechnique of suggesting action, character, or emotion without words, using only gesture, expression, and movement.\n\n\nIn a semi-cheeky fashion, \nMim\n handles everything else; the words, however, are yours to add.\n\n\nHow to use this document\n\n\nThis document provides everything you need to write your own Mim-speaking program that can communicate with other Mim clients.\n\n\nContents\n\n\n\n\nEntities: Basic protocol objects\n\n\nAPI: Information on how to use and query other Mim clients\n\n\nEndpoints: Building and targeting queries for other clients, and the answer format\n\n\nCommon flow: The most common series of actions that you will likely need to implement\n\n\nUsage examples: Example requests and responses\n\n\nFAQ\n\n\nAbout", 
            "title": "Home"
        }, 
        {
            "location": "/#mim-protocol-v01", 
            "text": "Mim is a distributed, peer-to-peer network protocol that distributes text. It's the protocol underlying Aether, which is the reference implementation of the Mim protocol.  Mim, at a very basic level, can be likened to a more decentralised Usenet where everyone is their own Usenet server. Building on that base platform, Mim adds modern features we've come to expect from our tools of communication.", 
            "title": "Mim Protocol v0.1"
        }, 
        {
            "location": "/#features", 
            "text": "Mim provides, in a peer-to-peer fashion:   The ability to freely create boards, threads and posts within them  Upvoting, downvoting posts and thus provide community moderation  Admin-moderating the communities you have created,  But also the right for your communities to reject your moderation  Add and remove moderators for admins  And also the ability to have unmoderated communities that rely completely on community moderation  Spam and sybil protection with proof-of-work, blocking and a reputation system  Unique identities and usernames with cryptographic signatures (optional)  On the other side, posting without a signature, thus remaining anonymous  An extensible protocol that can accommodate new object types, and proper structure to declare extensions.  In addition, it provides static nodes, which are static websites that can be used as containers of information available for everyone   Mim does not require need infrastructure, and is completely independent of anything except a working Internet connection. Nodes bootstrap off of each other when they join the network. The only thing you need to know is an IP and a Port that is a Mim node. In most practical cases, Mim client applications come with their own bootstrap nodes.", 
            "title": "Features"
        }, 
        {
            "location": "/#philosophy", 
            "text": "The aim of the author is to create an underlying common-language between computers for human discussion that is ubiquitous and free.  \"Mim\" name is a reference to  mime , the  technique of suggesting action, character, or emotion without words, using only gesture, expression, and movement.  In a semi-cheeky fashion,  Mim  handles everything else; the words, however, are yours to add.", 
            "title": "Philosophy"
        }, 
        {
            "location": "/#how-to-use-this-document", 
            "text": "This document provides everything you need to write your own Mim-speaking program that can communicate with other Mim clients.", 
            "title": "How to use this document"
        }, 
        {
            "location": "/#contents", 
            "text": "Entities: Basic protocol objects  API: Information on how to use and query other Mim clients  Endpoints: Building and targeting queries for other clients, and the answer format  Common flow: The most common series of actions that you will likely need to implement  Usage examples: Example requests and responses  FAQ  About", 
            "title": "Contents"
        }, 
        {
            "location": "/entity_concepts/", 
            "text": "Fingerprints, Cryptographic Signatures and Proof of Work\n\n\nFingerprints are how objects refer to other. A fingerprint is a SHA256 hash of the object. Signatures are how objects are linked to their creators. A signature is an ECDSA signature with the user's private key, and can only be created by the user creating the object. Signatures are optional, it's OK to be anonymous and thus have no key and no signatures. Proof of Work provides protection against spam and DDoS by creation of objects computationally expensive enough to make bulk creation infeasible.\n\n\nAll entities except Address have the fields of Proof of Work, Signature, and Fingerprint. When creating objects, proof of work happens first, signature happens second, and fingerprint happens last. When verifying, fingerprint is verified first, signature is verified second, and PoW is verified last. Failure of any of these checks should cause the object to be thrown out with no further processing.\n\n\nFingerprint is only done on the immutable parts of an object. Signatures and PoWs are done for immutable and mutable parts of the objects, separately. If you are creating an object with mutable parts, you will be creating one fingerprint, but two signatures and two PoWs. For both of those, the first one signs and PoWs the immutable part, and the second one the mutable part. This allows mutable part to change without invalidating the immutable parts' fingerprints, signatures and PoWs which are used in referring to the object, thus should remain valid and nonchanging.\n\n\nNulling out fields\n\n\nCreating proofs of work, signatures and fingerprints require emptying out certain fields in the object you are working on while you are generating them.\n\n\n\n\nThe empty state for string fields is \"\".\n\n\nThe empty state for number fields is 0.\n\n\nThe empty state for array fields is [].\n\n\n\n\nEmptying out does not mean actually changing the objects in any persistent. It means removing data from the in-memory objects, so that the calculations can be performed correctly. The creation steps provided below should \nnever\n remove data, though it can add data to the object. Verification steps should \nnever\n modify the object in a persistent way.\n\n\nOrder of processing\n\n\nThe order in which you should generate these is this:\n\n\n1) Signature\n\n\n2) Proof of Work (In the last step of PoW, PoW signs itself with the user's key. See \"Why?\" below for the reason.)\n\n\n3) Fingerprint\n\n\nWhy?\n\n\nSignature provides identification. PoW provides a guaranteed cost to the sender to prevent spam. Fingerprint provides addressability. If you have PoW before signature (the order being, Signature, PoW, Fingerprint), then signature itself will not be covered under the guarantee of PoW. A spammer can generate many users and use the same proof of work without expending the effort PoW attempts to enforce.\n\n\nIf we do the reverse (the order being, PoW, Signature, Fingerprint), and have signature before proof of work, then the proof of work can be replaced by third parties. A third party can generate another proof of work for the signed post, generate a new fingerprint, and release it as a new post that was created by the owner of the signature. This post would have to be the same, however, it would still be a different post with a different fingerprint (because of the different proof of work).\n\n\nThis post could be used to split votes to a post by generating hundreds of copies of the same post. Assuming a post would generate 200 upvotes and be visible as such, copying the same post 20 times and distributing it would generate 10 upvotes for each of the posts, all of which would be visible as a post with 10 upvotes, not 200. This could be used to effectively 'kill' posts.\n\n\nThe solution to this is to have the PoW sign itself with the private key, as part of the PoW process. This authenticates the PoW as generated by the original owner, and renders any posts with unsigned or malsigned PoW invalid.\n\n\nSignature\n\n\nSignature is the thing that makes the object be associated with you. If you are an anonymous user, you will not have a key, so you will not have signatures on any objects. If you do have a key (i.e. if you decided to pick an username) this is how other nodes verify that the objects are actually coming from you (more specifically, signed by a key that is only in your possession).\n\n\nIt's perfectly okay for an object to have no signature, however, clients can elect to not show or communicate anonymous posts due to end user preferences. On the other hand, not transmitting or showing objects with low proof-of-work levels and no keys are great ways to make sure the quality of objects shown is high.\n\n\nThe signature algorithm is ECDSA. The specific curve is given at the 'type' field of the key object, but is usually secp521r1.\n\n\nMind that different libraries of cryptography aren't necessarily interoperable, they sometimes provide outputs in different formats. Make sure that the library you are using is able to operate within what's available in the protocol, and can provide results that can be processed by others.\n\n\nSignature length will vary based on the algorithm, but here is an example of an 256 bit signature:\n\n\n3066023100d97a621fe650b9574bf5d0cd4c8981fff88f0679e86512be5b3abb59d3bfa8efa7df7fc32bfc588018f4f0acd36060a9023100ed28e6b0d513d227a3a186044dc3cad8872968bc72ee09e0dd0dcfed29f960e5ccacb8c55e1c77a8e276b2be09339400\n\n\n\n\nIn your objects, the update signatures are verified against the key of the original signature so that the update cannot be made by a different key.\n\n\nIf you end up with a signature failure, just throw out the object. You should not block the key owner, because the failures could be due to modification by someone else.\n\n\nCreating signatures\n\n\n1) Convert your object to JSON\n\n\n2) Empty out the Fingerprint, Hashcash, and all mutable fields (these should already be empty as they are not created yet at this stage)\n\n\n3) Run Signature algorithm over the stringified version of the JSON object\n\n\n4) Save it to the appropriate field of the object you just created the signature for.\n\n\nVerifying signatures\n\n\n1) Convert your object to JSON\n\n\n2) Empty out the Fingerprint, Hashcash, \nSignature\n, and all mutable fields\n\n\n3) Stringify your JSON object\n\n\n5) Run the algorithm to verify\n\n\nProof of Work\n\n\nEvery entity in Mim allows the local computer to prove that it has spent a certain amount of CPU power to create it. The amount of work to be proved is variable and can be set by the end user. The remote computer has the right to refuse or not take into consideration objects that it deems insufficiently proven of work, so try to keep this as high as you can tolerate. This is a measure that makes it too expensive for spammers to create posts in bulk and DDoS the network.\n\n\nProof of Work in Mim uses Hashcash method, and is optional.\n\n\nThe proof of work function in Mim is SHA256 x 3.\n\n\nMind that an empty proof of work field is a valid object, but a false proof-of-work field in an object is not. If your object has empty proof of work, you can continue processing it and show / not show, or communicate / not communicate (to other nodes) based on your preferences. But if you receive a PoW that does not successfully verify, you have a malformed object, and you should throw it out without any further consideration.\n\n\nThe nodes can have different proof of work requirements for different objects and states.\n\n\nAn example signed proof of work would be this:\n\n\n[version]:[difficulty]:[date]:[input]:[extension]:[salt]:[counter]:[signature]\n\n\n\n\nAn example unsigned proof of work would be this:\n\n\n[version]:[difficulty]:[date]:[input]:[extension]:[salt]:[counter]:\n\n\n\n\n(The trailing \":\" needs to be present.)\n\n\nAs you can see above, while Mim uses the Hashcash PoW. However, Mim Hashcash declares itself by declaring the version as \nMIM1\n. It also omits the fields of \ndate\n, \ninput\n, and \nextension\n. This is because Hashcash format includes redundant data fields that are already expressed in other fields of a Mim object.\n\n\nCreating proof of work\n\n\n1) convert your object to JSON\n\n\n2) Empty out the Fingerprint, and all mutable fields\n\n\n3) Run Hashcash over the stringified version of the JSON object\n\n\n4) After getting the hashcash result, get the private key, sign the result. Add the signature to the end of the hashcash result.\n\n\n5) Save it to the appropriate field of the object you just created the PoW for.\n\n\nVerifying proof of work\n\n\n1) Convert your object to JSON\n\n\n2) Empty out the Fingerprint, \nProof of Work\n and all mutable fields\n\n\n3) Stringify your JSON object\n\n\n4) Verify the PoW itself by running it through the signature validation process.\n\n\n4) Remove the latter portion of your PoW field starting with the \":\", including the \":\". This part was the signature.\n\n\n5) Run Hashcash Verify.\n\n\nFingerprint\n\n\nThis is relatively straightforward. Fingerprints are SHA256 hashes of the entire JSON of the object except mutable fields, and it is how objects refer to each other. If you have a thread, it will have the fingerprint of the parent board in its board field. You should always check to make sure fingerprint matches the object first before doing anything else with the object. If the fingerprint (hash) does not match, the object is malformed either in transit or intentionally. You should throw out the object with no further processing.\n\n\nCreating fingerprints\n\n\n1) Convert your object to JSON\n\n\n2) Empty out all mutable fields\n\n\n3) Run SHA256 hash algorithm over the stringified version of the JSON object\n\n\n4) Save it to the appropriate field of the object you just created the signature for.\n\n\nVerifying fingerprints\n\n\n1) Convert your object to JSON\n\n\n2) Empty out the \nFingerprint\n and all mutable fields\n\n\n3) Stringify your JSON object\n\n\n4) Run the algorithm to verify\n\n\nUpdateSignatures and UpdateProofOfWork\n\n\nThese fields are only available on objects which have mutable fields. These fields provide PoW and Signatures for the mutable fields of the object, and computed using \nall\n fields of the objects. In other words, the normal variations of Signature and ProofOfWork fields provide coverage for only the immutable fields, but UpdateSignature and UpdateProofOfWork provide coverage for both immutable and mutable fields.\n\n\nEvery time you change any mutable fields, you should be generating a new timestamp for the LastUpdate field, and creating new UpdateProofOfWork and UpdateSignature fields. Other nodes will apply the latest timestamped update onto the object they have, provided that your new PoW satisfies their minimum PoW requirements and the signature verifies. The reason there is a PoW on updates is to prevent any key holder from spamming the network with updates.", 
            "title": "Entity Concepts"
        }, 
        {
            "location": "/entity_concepts/#fingerprints-cryptographic-signatures-and-proof-of-work", 
            "text": "Fingerprints are how objects refer to other. A fingerprint is a SHA256 hash of the object. Signatures are how objects are linked to their creators. A signature is an ECDSA signature with the user's private key, and can only be created by the user creating the object. Signatures are optional, it's OK to be anonymous and thus have no key and no signatures. Proof of Work provides protection against spam and DDoS by creation of objects computationally expensive enough to make bulk creation infeasible.  All entities except Address have the fields of Proof of Work, Signature, and Fingerprint. When creating objects, proof of work happens first, signature happens second, and fingerprint happens last. When verifying, fingerprint is verified first, signature is verified second, and PoW is verified last. Failure of any of these checks should cause the object to be thrown out with no further processing.  Fingerprint is only done on the immutable parts of an object. Signatures and PoWs are done for immutable and mutable parts of the objects, separately. If you are creating an object with mutable parts, you will be creating one fingerprint, but two signatures and two PoWs. For both of those, the first one signs and PoWs the immutable part, and the second one the mutable part. This allows mutable part to change without invalidating the immutable parts' fingerprints, signatures and PoWs which are used in referring to the object, thus should remain valid and nonchanging.  Nulling out fields  Creating proofs of work, signatures and fingerprints require emptying out certain fields in the object you are working on while you are generating them.   The empty state for string fields is \"\".  The empty state for number fields is 0.  The empty state for array fields is [].   Emptying out does not mean actually changing the objects in any persistent. It means removing data from the in-memory objects, so that the calculations can be performed correctly. The creation steps provided below should  never  remove data, though it can add data to the object. Verification steps should  never  modify the object in a persistent way.  Order of processing  The order in which you should generate these is this:  1) Signature  2) Proof of Work (In the last step of PoW, PoW signs itself with the user's key. See \"Why?\" below for the reason.)  3) Fingerprint  Why?  Signature provides identification. PoW provides a guaranteed cost to the sender to prevent spam. Fingerprint provides addressability. If you have PoW before signature (the order being, Signature, PoW, Fingerprint), then signature itself will not be covered under the guarantee of PoW. A spammer can generate many users and use the same proof of work without expending the effort PoW attempts to enforce.  If we do the reverse (the order being, PoW, Signature, Fingerprint), and have signature before proof of work, then the proof of work can be replaced by third parties. A third party can generate another proof of work for the signed post, generate a new fingerprint, and release it as a new post that was created by the owner of the signature. This post would have to be the same, however, it would still be a different post with a different fingerprint (because of the different proof of work).  This post could be used to split votes to a post by generating hundreds of copies of the same post. Assuming a post would generate 200 upvotes and be visible as such, copying the same post 20 times and distributing it would generate 10 upvotes for each of the posts, all of which would be visible as a post with 10 upvotes, not 200. This could be used to effectively 'kill' posts.  The solution to this is to have the PoW sign itself with the private key, as part of the PoW process. This authenticates the PoW as generated by the original owner, and renders any posts with unsigned or malsigned PoW invalid.", 
            "title": "Fingerprints, Cryptographic Signatures and Proof of Work"
        }, 
        {
            "location": "/entity_concepts/#signature", 
            "text": "Signature is the thing that makes the object be associated with you. If you are an anonymous user, you will not have a key, so you will not have signatures on any objects. If you do have a key (i.e. if you decided to pick an username) this is how other nodes verify that the objects are actually coming from you (more specifically, signed by a key that is only in your possession).  It's perfectly okay for an object to have no signature, however, clients can elect to not show or communicate anonymous posts due to end user preferences. On the other hand, not transmitting or showing objects with low proof-of-work levels and no keys are great ways to make sure the quality of objects shown is high.  The signature algorithm is ECDSA. The specific curve is given at the 'type' field of the key object, but is usually secp521r1.  Mind that different libraries of cryptography aren't necessarily interoperable, they sometimes provide outputs in different formats. Make sure that the library you are using is able to operate within what's available in the protocol, and can provide results that can be processed by others.  Signature length will vary based on the algorithm, but here is an example of an 256 bit signature:  3066023100d97a621fe650b9574bf5d0cd4c8981fff88f0679e86512be5b3abb59d3bfa8efa7df7fc32bfc588018f4f0acd36060a9023100ed28e6b0d513d227a3a186044dc3cad8872968bc72ee09e0dd0dcfed29f960e5ccacb8c55e1c77a8e276b2be09339400  In your objects, the update signatures are verified against the key of the original signature so that the update cannot be made by a different key.  If you end up with a signature failure, just throw out the object. You should not block the key owner, because the failures could be due to modification by someone else.  Creating signatures  1) Convert your object to JSON  2) Empty out the Fingerprint, Hashcash, and all mutable fields (these should already be empty as they are not created yet at this stage)  3) Run Signature algorithm over the stringified version of the JSON object  4) Save it to the appropriate field of the object you just created the signature for.  Verifying signatures  1) Convert your object to JSON  2) Empty out the Fingerprint, Hashcash,  Signature , and all mutable fields  3) Stringify your JSON object  5) Run the algorithm to verify", 
            "title": "Signature"
        }, 
        {
            "location": "/entity_concepts/#proof-of-work", 
            "text": "Every entity in Mim allows the local computer to prove that it has spent a certain amount of CPU power to create it. The amount of work to be proved is variable and can be set by the end user. The remote computer has the right to refuse or not take into consideration objects that it deems insufficiently proven of work, so try to keep this as high as you can tolerate. This is a measure that makes it too expensive for spammers to create posts in bulk and DDoS the network.  Proof of Work in Mim uses Hashcash method, and is optional.  The proof of work function in Mim is SHA256 x 3.  Mind that an empty proof of work field is a valid object, but a false proof-of-work field in an object is not. If your object has empty proof of work, you can continue processing it and show / not show, or communicate / not communicate (to other nodes) based on your preferences. But if you receive a PoW that does not successfully verify, you have a malformed object, and you should throw it out without any further consideration.  The nodes can have different proof of work requirements for different objects and states.  An example signed proof of work would be this:  [version]:[difficulty]:[date]:[input]:[extension]:[salt]:[counter]:[signature]  An example unsigned proof of work would be this:  [version]:[difficulty]:[date]:[input]:[extension]:[salt]:[counter]:  (The trailing \":\" needs to be present.)  As you can see above, while Mim uses the Hashcash PoW. However, Mim Hashcash declares itself by declaring the version as  MIM1 . It also omits the fields of  date ,  input , and  extension . This is because Hashcash format includes redundant data fields that are already expressed in other fields of a Mim object.  Creating proof of work  1) convert your object to JSON  2) Empty out the Fingerprint, and all mutable fields  3) Run Hashcash over the stringified version of the JSON object  4) After getting the hashcash result, get the private key, sign the result. Add the signature to the end of the hashcash result.  5) Save it to the appropriate field of the object you just created the PoW for.  Verifying proof of work  1) Convert your object to JSON  2) Empty out the Fingerprint,  Proof of Work  and all mutable fields  3) Stringify your JSON object  4) Verify the PoW itself by running it through the signature validation process.  4) Remove the latter portion of your PoW field starting with the \":\", including the \":\". This part was the signature.  5) Run Hashcash Verify.", 
            "title": "Proof of Work"
        }, 
        {
            "location": "/entity_concepts/#fingerprint", 
            "text": "This is relatively straightforward. Fingerprints are SHA256 hashes of the entire JSON of the object except mutable fields, and it is how objects refer to each other. If you have a thread, it will have the fingerprint of the parent board in its board field. You should always check to make sure fingerprint matches the object first before doing anything else with the object. If the fingerprint (hash) does not match, the object is malformed either in transit or intentionally. You should throw out the object with no further processing.  Creating fingerprints  1) Convert your object to JSON  2) Empty out all mutable fields  3) Run SHA256 hash algorithm over the stringified version of the JSON object  4) Save it to the appropriate field of the object you just created the signature for.  Verifying fingerprints  1) Convert your object to JSON  2) Empty out the  Fingerprint  and all mutable fields  3) Stringify your JSON object  4) Run the algorithm to verify", 
            "title": "Fingerprint"
        }, 
        {
            "location": "/entity_concepts/#updatesignatures-and-updateproofofwork", 
            "text": "These fields are only available on objects which have mutable fields. These fields provide PoW and Signatures for the mutable fields of the object, and computed using  all  fields of the objects. In other words, the normal variations of Signature and ProofOfWork fields provide coverage for only the immutable fields, but UpdateSignature and UpdateProofOfWork provide coverage for both immutable and mutable fields.  Every time you change any mutable fields, you should be generating a new timestamp for the LastUpdate field, and creating new UpdateProofOfWork and UpdateSignature fields. Other nodes will apply the latest timestamped update onto the object they have, provided that your new PoW satisfies their minimum PoW requirements and the signature verifies. The reason there is a PoW on updates is to prevent any key holder from spamming the network with updates.", 
            "title": "UpdateSignatures and UpdateProofOfWork"
        }, 
        {
            "location": "/objects/", 
            "text": "Entities\n\n\nThese are the root level protocol objects that have their own endpoints.\n\n\n\n\nBoard\n\n\nThread\n\n\nPost\n\n\nVote\n\n\nAddress\n\n\nKey\n\n\nTrustState\n\n\n\n\nThese are the sub-level protocol objects that do not have their endpoints, and only provided integrated to the objects encapsulating them. You cannot query them on their own.\n\n\n\n\nBoardOwner (sub-entity of Board)\n\n\nProtocol (sub-entity of Address)\n\n\nClient (sub-entity of Address)\n\n\nCurrencyAddress (sub-entity of Key)\n\n\n\n\n\n\nBoard\n\n\nBoards are the Terminal top-level elements of the architecture. All posts belong to a board and a thread. Think of these as subreddits. They can have an owner, which is the person that created the board. This is the permanent moderator of the board. The permanent moderator can assign moderators for a limited timespan.\n\n\nBoard Object\n\n\nThis is the spec of the standard Board entity a Mim node will provide you. The order of these fields are undefined, it can come in any order.\n\n\n\n\nFingerprint (64 characters, ASCII string)\n\n\nName (Min 2, Max 255 characters, Unicode string)\n\n\nCreation (Unix Epoch Time, UTC, int64)\n\n\nProofOfWork (Min 0, Max 1024 characters, ASCII string)\n\n\nSignature (Min 0, Max 512 characters, ASCII string)\n\n\nBoardOwners (\nMutable\n, Min 0 array of BoardOwner objects, max 100)\n\n\nDescription (\nMutable\n, Min 0, Max 65535 characters, Unicode string)\n\n\nLastUpdate (\nMutable\n, Unix Epoch Time, UTC, int64)\n\n\nUpdateProofOfWork (\nMutable\n, Min 0, Max 1024 characters, ASCII string)\n\n\nUpdateSignature (\nMutable\n, Min 0, Max 512 characters, ASCII string)\n\n\n\n\nMutable fields in Board Object\n\n\n'BoardOwners', 'Description', 'LastUpdate', 'UpdateProofOfWork', 'UpdateSignature'\n\n\nMaximum uncompressed theoretical size\n\n\n~280 Kilobytes, assuming 100 (max) board owners, and assuming 65535 (max) characters on description, all characrers 4 bytes each (unicode max). On average, boards will likely have 1-2 owners, and 500-600 characters description. If average, ~20 kilobytes. Variance is moderate, but be ready to handle extreme cases.\n\n\nBoard Example\n\n\n{\n  \nfingerprint\n: \nea7d8e81e18e3791e0e89a4ebaba64c92c3f0f3c03c3057e2ef5e9fcb7f13891\n,\n  \nname\n: \nMy awesome board\n,\n  \ncreation\n: 1442040412,\n  \nproof_of_work\n: \n1:23:1509120719:[mimdata]::xUEBZA89/o7EZwtg:000000000000000000000000000000000GHiK\n,\n  \nsignature\n: \n30450221008829563cc1ac75659c440e9d737fb81d5a8f3f60cda48d041ed71c61adfcb5cb022026fbd30a651433778d4d94d774082ba66acd7dd1d43d8263e36972aba98c6a79\n,\n  \nboard_owners\n: [\n    {\n      \nkey_fingerprint\n: \nf1c4f90dd4a45bdb83b47e04e158065b9c7c867ffd44ea925c1301ad6134f2bd\n,\n      \nexpiry\n: \n,\n      \nlevel\n: 2\n    }\n  ],\n  \ndescription\n: \nThis is where you get to explain what your board is about.\n,\n  \nlast_update\n: 1442044141,\n  \nupdate_proof_of_work\n: \n1:24:1509120749:[mimdata]::hyVUb0vRzJsxkZ4Q:0001tD3/\n,\n  \nupdate_signature\n: \n3046022100ce06189f3aea609a095aebb2a8ff4115af18c15abc0e84ff07ee7ba5687a3502022100bc7676c71e81208e179afc7fe0302ac1433ce22527d673ed291dd0965d4e5e58\n\n}\n\n\n\n\nBoard Index Form Example\n\n\nThis form is the compressed form of the full object. It is provided in the index so as to allow the requester to decide whether it wants to request this object or not. If the requester thinks this object is useful, it needs to request the full object to be able to do anything with it.\n\n\n{\n  \nfingerprint\n: \nedb4e3da4e8f1e99aba3743fc3de5a84f73e4fd32f5883759e743582a25cb466\n,\n  \ncreation\n: 1442041028,\n  \nlast_update\n: 1442099904,\n  \npage_number\n: 0 // Only appears on index form. Allows for faster queries.\n}\n\n\n\n\nFields\n\n\nFingerprint\n\n\nSHA256 hash of the entirety of the object. See entity concepts for how to come up and how to verify this.\n\n\nOf all the three calculations (proof of work, signature, fingerprint), this should happen last.\n\n\nName\n\n\nUser-visible portion of the board. Between 2 and 255 unicode characters. Do not assume this always means 255 bytes! A unicode character can be and is often larger than a byte.\n\n\nCreation\n\n\nCreation date and time in UTC as an int64. This is the standard UNIX Epoch Time.\n\n\nProofOfWork\n\n\nThis field provides proof of work. To see how to create and verify this, see the relevant section in the Entity Concepts topic.\n\n\nSignature\n\n\nThis field provides signatures. To see how to create and verify this, see the relevant section in the Entity Concepts topic.\n\n\nOf all the three calculations (proof of work, signature, fingerprint), this should happen second.\n\n\nBoardOwners\n\n\nAn array of BoardOwner objects. Can be empty. Updatable.\n\n\nWhen you convert this to a string, concat everything without any sort of delineation.\n\n\nDescription\n\n\nDescription of the board. Admin of the board can update this.\n\n\nLastUpdate\n\n\nUpdate date and time in UTC as an int64. This is the standard UNIX Epoch Time.\n\n\nUpdateProofOfWork\n\n\nThis field provides proof of work. To see how to create and verify this, see the relevant section in the Entity Concepts topic.\n\n\nUpdateSignature\n\n\nThis field provides signatures. To see how to create and verify this, see the relevant section in the Entity Concepts topic.\n\n\n\n\nBoardOwner (sub-entity of Board)\n\n\nBoardOwner entities go into the updatable 'BoardOwners' field of a board. They are not distributed separately, but embedded into 'Board' objects. There is no upper limit on how many owners a board can have. A board can also have no owners, in which case it is not moderated by mods but by community by means of voting.\n\n\nBoardOwner Object\n\n\n\n\nKeyFingerprint (64 characters, ASCII string)\n\n\nExpiry (Unix Epoch Time, UTC, int64, or empty)\n\n\nLevel (uint8. A number between 0-255)\n\n\n\n\nFields\n\n\nKeyFingerprint\n\n\nThis is the fingerprint of the key the ownership is associated to.\n\n\nExpiry\n\n\nWhen the ownership expires. Can be empty. If empty, ownership lasts until revoked by the admin of the board.\n\n\nLevel\n\n\nA number between 0 and 255. Values are given below:\n\n\n2: Admin. Can add and remove mods. Can remove itself. Can moderate.\n\n\n1: Mod. Cannot add or remove mods. Cannot remove itself. Can moderate.\n\n\n0: Abdicated admin. If an admin wants to remove itself, he or she sets his own level value to 0. Abdication is irrevocable.\n\n\nThread\n\n\nThreads are a collection of posts. They have a header, which is the name of the thread. They can either be text-based, in which the user writes some text as the discussion starter, or link-based, in which the thread is a link to an external page.\n\n\nThread Object\n\n\n\n\nFingerprint (64 characters, ASCII string)\n\n\nBoard (64 characters, ASCII string)\n\n\nName (Min 2, Max 255 characters, Unicode string)\n\n\nBody (Min 0, Max 65535 characters, Unicode string)\n\n\nLink (Min 0, Max 5000 characters, Unicode string)\n\n\nOwner (0 or 64 characters, ASCII string)\n\n\nCreation (Unix Epoch Time, UTC, int64)\n\n\nProofOfWork (Min 0, Max 1024 characters, ASCII string)\n\n\nSignature (Min 0, Max 512 characters, ASCII string)\n\n\n\n\nMaximum uncompressed theoretical size\n\n\n~280 Kilobytes, assuming 65535 (max) characters on body, 255 on name, and 5000 on link, all characrers 4 bytes each (unicode max). This wildly varies, be ready to handle extreme cases.\n\n\nThread Example\n\n\n{\n  \nfingerprint\n: \nea7d8e81e18e3791e0e89a4ebaba64c92c3f0f3c03c3057e2ef5e9fcb7f13891\n,\n  \nboard\n: \n14fc9b8593050a15ebdf2ebae13150315fa9b14e4e921b03f9912c6a2560b8f2\n,\n  \nname\n: \nMy awesome thread\n,\n  \nbody\n: \nThis is the body of the thread.\n,\n  \nlink\n: \nhttp://www.zombo.com\n,\n  \nowner\n: \nf1c4f90dd4a45bdb83b47e04e158065b9c7c867ffd44ea925c1301ad6134f2bd\n,\n  \ncreation\n: 1442040412,\n  \nproof_of_work\n: \n1:23:1509120719:[mimdata]::xUEBZA89/o7EZwtg:000000000000000000000000000000000GHiK\n,\n  \nsignature\n: \n30450221008829563cc1ac75659c440e9d737fb81d5a8f3f60cda48d041ed71c61adfcb5cb022026fbd30a651433778d4d94d774082ba66acd7dd1d43d8263e36972aba98c6a79\n,\n}\n\n\n\n\nThread Index Form Example\n\n\n{\n  \nfingerprint\n: \nedb4e3da4e8f1e99aba3743fc3de5a84f73e4fd32f5883759e743582a25cb466\n,\n  \nboard\n: \n71f12bb2278e400d7fec0a40c1944df32fbd0c6e91d10c7ec5e6bbf194b0f4e8\n,\n  \ncreation\n: 1442041028,\n  \npage_number\n: 0 // Only appears on index form. Allows for faster queries.\n}\n\n\n\n\nFields\n\n\nFingerprint\n\n\nSHA256 hash of the entirety of the object. To come up with the fingerprint, convert all the fields except itself into and unicode string and run SHA256 hash over it.\n\n\nOf all the three calculations (proof of work, signature, fingerprint), this should happen last.\n\n\nBoard\n\n\nFingerprint of the board this thread belongs to.\n\n\nName\n\n\nName of the thread. Between 2 and 255 unicode characters.\n\n\nBody\n\n\nMain text. Between 0 and 65535 characters unicode string. Can be empty.\n\n\nLink\n\n\nThe address the thread links to. Between 0 and 65535 characters unicode string. Can be empty.\n\n\nOwner\n\n\nFingerprint of a Key that owns this. Can be empty.\n\n\nCreation\n\n\nSee Board \n Creation field.\n\n\nProofOfWork\n\n\nThis field provides a a Hashcash token and its signature. To generate the string that goes into Hashcash, convert all fields except 'Fingerprint' and itself to a unicode string, concatenate them, and run Hashcash over with the configuration options. See 'Entity Concepts' section for more info.\n\n\nSignature\n\n\nECDSA signature of all fields except 'Fingerprint' and itself. Can be empty. For the exact ECDSA signature algorithm, please read on. [todo]\n\n\n\n\nPost\n\n\nPosts are comments written by users of the protocol. They can be replies directly to the thread, or to another post.\n\n\nPost Object\n\n\n\n\nFingerprint (64 characters, ASCII string)\n\n\nBoard (64 characters, ASCII string)\n\n\nThread (64 characters, ASCII string)\n\n\nParent (64 characters, ASCII string)\n\n\nBody (Min 0, Max 65535 characters, Unicode string)\n\n\nOwner (0 or 64 characters, ASCII string)\n\n\nCreation (Unix Epoch Time, UTC, int64)\n\n\nProofOfWork (Min 0, Max 1024 characters, ASCII string)\n\n\nSignature (Min 0, Max 512 characters, ASCII string)\n\n\n\n\nMaximum uncompressed theoretical size\n\n\n~280 Kilobytes, assuming 65535 (max) characters on body, all characters 4 bytes each (unicode max). This wildly varies, so while average post length is 1000~ characters and is mostly ASCII (1 bytes), be ready to handle extreme cases.\n\n\nPost Example\n\n\n{\n  \nfingerprint\n: \nea7d8e81e18e3791e0e89a4ebaba64c92c3f0f3c03c3057e2ef5e9fcb7f13891\n,\n  \nboard\n: \n64c74b58966274583ebe2e177e8f53da090cecf91a8d21d173e1af48d3ea3f21\n,\n  \nthread\n: \nf1c4f90dd4a45bdb83b47e04e158065b9c7c867ffd44ea925c1301ad6134f2bd\n,\n  \nparent\n: \nf1c4f90dd4a45bdb83b47e04e158065b9c7c867ffd44ea925c1301ad6134f2bd\n, // if same as board, it's a direct post to the thread.\n  \nbody\n: \nThis is my post.\n,\n  \nowner\n: \n623429db9c6e9bd441b5d6ceaaeeb80a1066f4a0cdbc83722bb970f67700b22f\n,\n  \ncreation\n: 1442040412,\n  \nproof_of_work\n: \n1:23:1509120719:[mimdata]::xUEBZA89/o7EZwtg:000000000000000000000000000000000GHiK\n,\n  \nsignature\n: \n30450221008829563cc1ac75659c440e9d737fb81d5a8f3f60cda48d041ed71c61adfcb5cb022026fbd30a651433778d4d94d774082ba66acd7dd1d43d8263e36972aba98c6a79\n,\n}\n\n\n\n\nPost Index Form Example\n\n\n{\n  \nfingerprint\n: \nedb4e3da4e8f1e99aba3743fc3de5a84f73e4fd32f5883759e743582a25cb466\n,\n  \nboard\n: \n71f12bb2278e400d7fec0a40c1944df32fbd0c6e91d10c7ec5e6bbf194b0f4e8\n,\n  \nthread\n: \n81b3c8d7ae3fa2b971e811834e61e4d6a30c246fb04ac309b267c1dc369cb902\n,\n  \ncreation\n: 1442041028,\n  \npage_number\n: 0 // Only appears on index form. Allows for faster queries.\n}\n\n\n\n\nFields\n\n\nFingerprint\n\n\nSee Thread \n Fingerprint field.\n\n\nBoard\n\n\nFingerprint of the board this post belongs to.\n\n\nThread\n\n\nFingerprint of the thread this post belongs to.\n\n\nParent\n\n\nFingerprint of the entity that is the ancestor to this post.\n\n\nBody\n\n\nSee Thread \n Body field.\n\n\nOwner\n\n\nSee Thread \n Owner field.\n\n\nCreation\n\n\nSee Board \n Creation field.\n\n\nProofOfWork\n\n\nSee Thread \n ProofOfWork field.\n\n\nSignature\n\n\nSee Thread \n Signature field.\n\n\n\n\nVote\n\n\nVote objects are emitted when people vote on threads or posts. These are signed by user's private keys, so the user can vote only once on a certain entity. If user's vote changes, his or her vote will update accordingly across the network.\n\n\nVote Object\n\n\n\n\nFingerprint (64 characters, ASCII string)\n\n\nBoard (64 characters, ASCII string)\n\n\nThread (64 characters, ASCII string)\n\n\nTarget (64 characters, ASCII string)\n\n\nOwner (64 characters, ASCII string)\n\n\nCreation (Unix Epoch Time, UTC, int64)\n\n\nProofOfWork (Min 0, Max 1024 characters, ASCII string)\n\n\nSignature (Min 0, Max 512 characters, ASCII string)\n\n\nType (\nMutable\n, uint8. A number between 0-255)\n\n\nLastUpdate (\nMutable\n, Unix Epoch Time, UTC, int64)\n\n\nUpdateProofOfWork (\nMutable\n, Min 0, Max 1024 characters, ASCII string)\n\n\nUpdateSignature (\nMutable\n, Min 0, Max 512 characters, ASCII string)\n\n\n\n\nMutable fields in Vote Object\n\n\n'Type', 'LastUpdate', 'UpdateProofOfWork', 'UpdateSignature'\n\n\nMaximum uncompressed theoretical size\n\n\n~1 Kilobytes.\n\n\nVote Example\n\n\n{\n  \nfingerprint\n: \nea7d8e81e18e3791e0e89a4ebaba64c92c3f0f3c03c3057e2ef5e9fcb7f13891\n,\n  \nboard\n: \n64c74b58966274583ebe2e177e8f53da090cecf91a8d21d173e1af48d3ea3f21\n,\n  \nthread\n: \nf1c4f90dd4a45bdb83b47e04e158065b9c7c867ffd44ea925c1301ad6134f2bd\n,\n  \ntarget\n: \nf1c4f90dd4a45bdb83b47e04e158065b9c7c867ffd44ea925c1301ad6134f2bd\n,\n  \nowner\n: \n623429db9c6e9bd441b5d6ceaaeeb80a1066f4a0cdbc83722bb970f67700b22f\n,\n  \ncreation\n: 1442040412,\n  \nproof_of_work\n: \n1:23:1509120719:[mimdata]::xUEBZA89/o7EZwtg:000000000000000000000000000000000GHiK\n,\n  \nsignature\n: \n30450221008829563cc1ac75659c440e9d737fb81d5a8f3f60cda48d041ed71c61adfcb5cb022026fbd30a651433778d4d94d774082ba66acd7dd1d43d8263e36972aba98c6a79\n,\n  \ntype\n: 1,\n  \nlast_update\n: 1442044141,\n  \nupdate_proof_of_work\n: \n1:24:1509120749:[mimdata]::hyVUb0vRzJsxkZ4Q:0001tD3/\n,\n  \nupdate_signature\n: \n3046022100ce06189f3aea609a095aebb2a8ff4115af18c15abc0e84ff07ee7ba5687a3502022100bc7676c71e81208e179afc7fe0302ac1433ce22527d673ed291dd0965d4e5e58\n\n}\n\n\n\n\nVote Index Form Example\n\n\n{\n  \nfingerprint\n: \nedb4e3da4e8f1e99aba3743fc3de5a84f73e4fd32f5883759e743582a25cb466\n,\n  \nboard\n: \n71f12bb2278e400d7fec0a40c1944df32fbd0c6e91d10c7ec5e6bbf194b0f4e8\n,\n  \nthread\n: \n81b3c8d7ae3fa2b971e811834e61e4d6a30c246fb04ac309b267c1dc369cb902\n,\n  \ntarget\n: \n81b3c8d7ae3fa2b971e811834e61e4d6a30c246fb04ac309b267c1dc369cb902\n,\n  \ncreation\n: 1442041028,\n  \nlast_update\n: 1442099904,\n  \npage_number\n: 0 // Only appears on index form. Allows for faster queries.\n}\n\n\n\n\nFields\n\n\nFingerprint\n\n\nSee Board \n Fingerprint field.\n\n\nBoard\n\n\nSee Post \n Board field.\n\n\nThread\n\n\nSee Post \n Thread field.\n\n\nTarget\n\n\nThe target of this vote. Can be post or a thread.\n\n\nOwner\n\n\nSee Post \n Owner field.\n\n\nCreation\n\n\nSee Post \n Creation field.\n\n\nProofOfWork\n\n\nSee Post \n ProofOfWork field.\n\n\nSignature\n\n\nSee Post \n Signature field.\n\n\nType\n\n\nA value between 0 and 255. (uint8)\n\n\nType values\n\n\n0: Neutral vote. This is assumed if no vote is available. If you see this, this was reverted back from some other type of vote.\n\n\n1: Upvote (Applicable to Posts, Threads)\n\n\n2: Downvote (Applicable to Posts, Threads)\n\n\n3: Pinned (Applicable to Posts, Threads)\n\n\n4: Blocked (Applicable to Posts, Threads, Boards)\n\n\nLastUpdate\n\n\nSee Board \n LastUpdate field.\n\n\nUpdateProofOfWork\n\n\nSee Board \n UpdateProofOfWork field.\n\n\nUpdateSignature\n\n\nSee Board \n UpdateSignature field.\n\n\n\n\nAddress\n\n\nAddress objects are IP addresses running a Mim client. They can be of a certain type, or be running a protocol extension. You decide whether to connect to these with protocol version and with the extensions they are running.\n\n\nAddress Object\n\n\n\n\nLocation (Max 2500 characters ASCII string)\n\n\nSublocation (Max 2500 characters ASCII string)\n\n\nLocationType (6 or 4 or 3, single integer)\n\n\nPort (uint16. A number between 0-65535)\n\n\nType (\nMutable\n, uint8. A number between 0-255)\n\n\nLastOnline (\nMutable\n, Unix Epoch Time, UTC, int64)\n\n\nProtocol (\nMutable\n, Protocol object)\n\n\nClient (\nMutable\n, Client object)\n\n\n\n\nMutable fields in Address Object\n\n\nAddress fields are mutable only when directly connected to that address. In other words, addresses are collected from the network only once. An update based on the data coming from another node which is not at the address is not permitted. This is so as to mitigate an attack vector in which the attacker cuts off or encourages the connections (DDoS) to an address by changing the details used to make dispatch decisions on other nodes.\n\n\n'Type', 'LastOnline', 'Protocol', 'Client'\n\n\nMaximum uncompressed theoretical size\n\n\n~8 Kilobytes, assuming 100 (max) extensions each 64 characters ASCII (max), 255 characters unicode as client name (max). Average number of extensions is likely 0-1. Average length of client name is likely 7-10 bytes. If average, ~0.5 Kilobytes.\n\n\nAddress Example\n\n\n{\n  \nlocation\n: \n1.2.3.4\n,\n  \nsublocation\n: \n,\n  \nlocation_type\n: 4,\n  \nport\n: 23432,\n  \ntype\n: 2,\n  \nlast_online\n: 1442044141,\n  \nprotocol\n: {\n    \nversion_major\n: 0,\n    \nversion_minor\n: 1,\n    \nextensions\n: []\n  },\n  \nclient\n: {\n    \nversion_major\n: 2,\n    \nversion_minor\n: 0,\n    \nversion_patch\n: 0,\n    \nname\n: \nAether\n\n  }\n}\n\n\n\n\nAddress Index Form Example\n\n\nThe index form of address is the address entity itself.\n\n\n{\n  \nlocation\n: \n1.2.3.4\n,\n  \nsublocation\n: \n,\n  \nlocation_type\n: 4,\n  \nport\n: 23432,\n  \ntype\n: 2,\n  \nlast_online\n: 1442044141,\n  \nprotocol\n: {\n    \nversion_major\n: 0,\n    \nversion_minor\n: 1,\n    \nextensions\n: []\n  },\n  \nclient\n: {\n    \nversion_major\n: 2,\n    \nversion_minor\n: 0,\n    \nversion_patch\n: 0,\n    \nname\n: \nAether\n\n  }\n}\n\n\n\n\nFields\n\n\nLocation\n\n\nIp address, v4 or v6 (127.0.0.1) or root URL. (http://www.example.com)\n\n\nSublocation\n\n\nIf location is URL, this is the non-root part. i.e. (my_awesome_static_node)\n\n\nCombined with the root URL above, this means the node is at http://www.example.com/my_awesome_static_node\n\n\nLocationType\n\n\nThe type of IP address. It can either be 4 or 6 or 3. 3 means it's a URL.\n\n\nPort\n\n\nThe Mim port of the address. An uint16 number between 0-65535.\n\n\nType\n\n\nMim type of the address.\n\n\nType values\n\n\n0: Static. This node is 'frozen'. It will not respond to filter queries, just to show all requests. An example of this node is a static website.\n\n\n1: Ephemeral. This node is likely not going to be there when asked back. This is useful for a computing device to declare itself as ephemeral. An example of an ephemeral computing device would be a phone, or a tablet. These devices just pull data, read, and leave. They can write, so if a 'new content' signal is received from that node, it should be acted upon as soon as possible. How this signal will change the behaviour of the remote computer is left to the client implementation.\n\n\n2: Live. This is a normal computer that stays online for durations longer than a few minutes. This is the default setting.\n\n\nLastOnline\n\n\nThe date this node was last connected to.\n\n\nProtocol\n\n\nProtocol object which declares the protocol the address is running.\n\n\n\n\nProtocol (sub-entity of Address)\n\n\nDefines the protocol version and extensions the client is running. Protocol extensions are extensions to the Mim protocol where additional features and entities can be added.\n\n\nProtocol Object\n\n\n\n\nVersionMajor (uint8)\n\n\nVersionMinor (uint16)\n\n\nExtensions (array of strings, max 64 characters long each, ASCII max 100 extensions)\n\n\n\n\nFields\n\n\nVersionMajor\n\n\nMajor version of the Mim protocol running on this address.\n\n\nVersionMinor\n\n\nMinor version of the Mim protocol running on this address.\n\n\nExtensions\n\n\nThe array of strings, each of which define an extension to the Mim protocol. Max 100 extensions. Each string is maximum 64 characters ASCII.\n\n\n\n\nClient (sub-entity of Address)\n\n\nDefines the client that is running on this address. This object is empty if the node is static.\n\n\nClient Object\n\n\n\n\nVersionMajor (uint8)\n\n\nVersionMinor (uint16)\n\n\nVersionPatch (uint16)\n\n\nClientName (Max 255 characters Unicode)\n\n\n\n\nFields\n\n\nVersionMajor\n\n\nMajor version of the client running on this address.\n\n\nVersionMinor\n\n\nMinor version of the client running on this address.\n\n\nVersionPatch\n\n\nMinor version of the client running on this address.\n\n\nClientName\n\n\nName of the client running on this node. Max 255 characters Unicode.\n\n\n\n\nKey\n\n\nKeys represent unique users. Having a key is optional, i.e. you can write posts anonymously. However, the nodes might reject to receive these posts written in such a manner. If you do not have a key, you cannot vote.\n\n\nKey Object\n\n\n\n\nFingerprint  (64 characters, ASCII string)\n\n\nType (256 characters, ASCII String)\n\n\nKey (Max 65536 characters ASCII string)\n\n\nName (Max 64 characters Unicode)\n\n\nCreation (Unix Epoch Time, UTC, int64)\n\n\nProofOfWork (Min 0, Max 1024 characters, ASCII string)\n\n\nSignature (Min 0, Max 512 characters, ASCII string)\n\n\nCurrencyAddresses (\nMutable\n, Array of CurrencyAddress, Max 10.)\n\n\nInfo (\nMutable\n, Max 1024 characters Unicode.)\n\n\nLastUpdate (\nMutable\n, Unix Epoch Time, UTC, int64)\n\n\nUpdateProofOfWork (\nMutable\n, Min 0, Max 1024 characters, ASCII string)\n\n\nUpdateSignature (\nMutable\n, Min 0, Max 512 characters, ASCII string)\n\n\n\n\nMutable fields in Key Object\n\n\n'CurrencyAddresses', 'Info', 'LastUpdate', 'UpdateProofOfWork', 'UpdateSignature'\n\n\nMaximum uncompressed theoretical size\n\n\n~80 Kilobytes, assuming 10 (max) currency addresses with all their values at mex, 65535 characters ASCII (max) at key and all other values are maxed.. Length of the key used by default is 512 characters ASCII. Average number of currency addresses for a key is 0-1 If average, ~6 Kilobytes.\n\n\nKey Example\n\n\n{\n  \nfingerprint\n: \nea7d8e81e18e3791e0e89a4ebaba64c92c3f0f3c03c3057e2ef5e9fcb7f13891\n,\n  \ntype\n: \nsecp256k1\n,\n  \nname\n: \nburak\n,\n  \nkey\n: \n04da41af852dad151094de0e84a7c8a111cf93d56a2028c8400a1e9f9e37adffd4328a256228cc30387af52e507e33c28cf1accfda524800cdd5f17845ebc63168\n,\n  \ncreation\n: 1442040412,\n  \nproof_of_work\n: \n1:23:1509120719:[mimdata]::xUEBZA89/o7EZwtg:000000000000000000000000000000000GHiK\n,\n  \nsignature\n: \n30450221008829563cc1ac75659c440e9d737fb81d5a8f3f60cda48d041ed71c61adfcb5cb022026fbd30a651433778d4d94d774082ba66acd7dd1d43d8263e36972aba98c6a79\n,\n  \ncurrency_addresses\n: [\n    {\n      \ncurrency_code\n: \nXDG\n,\n      \naddress\n: \nea7d8e81e18e3791e0e89a4ebaba64c92c3f0f3c03c3057e2ef5e9fcb7f13891\n\n    }\n  ],\n  \ninfo\n: \nThis is the key information.\n,\n  \nlast_update\n: 1442044141,\n  \nupdate_proof_of_work\n: \n1:24:1509120749:[mimdata]::hyVUb0vRzJsxkZ4Q:0001tD3/\n,\n  \nupdate_signature\n: \n3046022100ce06189f3aea609a095aebb2a8ff4115af18c15abc0e84ff07ee7ba5687a3502022100bc7676c71e81208e179afc7fe0302ac1433ce22527d673ed291dd0965d4e5e58\n\n}\n\n\n\n\nKey Index Form Example\n\n\nThe index form of address is the address entity itself.\n\n\n{\n  \nfingerprint\n: \nedb4e3da4e8f1e99aba3743fc3de5a84f73e4fd32f5883759e743582a25cb466\n,\n  \ncreation\n: 1442041028,\n  \nlast_update\n: 1442099904,\n  \npage_number\n: 0 // Only appears on index form. Allows for faster queries.\n}\n\n\n\n\nFingerprint\n\n\nSee Board \n Fingerprint field.\n\n\nType\n\n\nThe type of the key, a string field, such as 'RSA2048'. There are no defined values of this field. Whatever you put there, make sure all other clients can decipher it. If this type is indecipherable to a client, it is required for the client to make a best-effort attempt to validate the key.\n\n\nKey\n\n\nThe key itself.\n\n\nName\n\n\nThe user name of the person who owns the key.\n\n\nCreation\n\n\nSee Thread \n Creation field.\n\n\nProofOfWork\n\n\nSee Thread \n ProofOfWork field.\n\n\nSignature\n\n\nSee Thread \n Signature field.\n\n\nCurrencyAddresses\n\n\nAn array of CurrencyAddress objects. Maximum 10 objects.\n\n\nInfo\n\n\nIdeally, some information about the owner of the key, alternative contact methods etc.\n\n\nLastUpdate\n\n\nSee Board \n LastUpdate field.\n\n\nUpdateProofOfWork\n\n\nSee Board \n UpdateProofOfWork field.\n\n\nUpdateSignature\n\n\nSee Board \n UpdateSignature field.\n\n\n\n\nCurrencyAddress (sub-entity of Key)\n\n\nDefines a currency where the user can be sent money out-of-band. Mim does not handle monetary transactions.\n\n\nCurrencyAddress Object\n\n\n\n\nCurrencyCode (Max 5 characters ASCII string, ISO 4217)\n\n\nAddress (Max 1024 characters ASCII string)\n\n\n\n\nFields\n\n\nCurrencyCode\n\n\nISO4217 Currency code of the currency in this address. The currencies not defined in ISO4217 should be based on consensus. If you are dealing with a cryptocurrency, the recommendation is to use X at the beginning and 2 letters for the currency. For example, Bitcoin would be XBT.\n\n\nAddress\n\n\nThe currency address of the keyholder in this currency.\n\n\n\n\nTrustState\n\n\nTrustState objects are declarations of trust of an user for another. If an user trusts, or distrusts another, it emits a TrustState. If the user changes an existing TrustState to neutral, it updates the state with a 'neutral'.\n\n\nTrustState Object\n\n\n\n\nFingerprint (64 characters, ASCII string)\n\n\nTarget (64 characters, ASCII string)\n\n\nOwner (64 characters, ASCII string)\n\n\nCreation (Unix Epoch Time, UTC, int64)\n\n\nProofOfWork (Min 0, Max 1024 characters, ASCII string)\n\n\nSignature (Min 0, Max 512 characters, ASCII string)\n\n\nType (\nMutable\n, uint8. A number between 0-255)\n\n\nDomains (\nMutable\n, Min 0, max 100 array of Board fingerprints)\n\n\nExpiry (\nMutable\n, Unix Epoch Time, UTC, int64)\n\n\nLastUpdate (\nMutable\n, Unix Epoch Time, UTC, int64)\n\n\nUpdateProofOfWork (\nMutable\n, Min 0, Max 1024 characters, ASCII string)\n\n\nUpdateSignature (\nMutable\n, Min 0, Max 512 characters, ASCII string)\n\n\n\n\nMutable fields in TrustState Object\n\n\n'Type', 'Domains', 'Expiry' 'LastUpdate', 'UpdateProofOfWork', 'UpdateSignature'\n\n\nMaximum uncompressed theoretical size\n\n\n~7 Kilobytes, assuming 100 (max) domains. Average number of domains is likely 1-2. If average, ~1 Kilobytes.\n\n\nTrustState Example\n\n\n{\n  \nfingerprint\n: \nea7d8e81e18e3791e0e89a4ebaba64c92c3f0f3c03c3057e2ef5e9fcb7f13891\n,\n  \ntarget\n: \nf1c4f90dd4a45bdb83b47e04e158065b9c7c867ffd44ea925c1301ad6134f2bd\n,\n  \nowner\n: \n623429db9c6e9bd441b5d6ceaaeeb80a1066f4a0cdbc83722bb970f67700b22f\n,\n  \ncreation\n: 1442040412,\n  \nproof_of_work\n: \n1:23:1509120719:[mimdata]::xUEBZA89/o7EZwtg:000000000000000000000000000000000GHiK\n,\n  \nsignature\n: \n30450221008829563cc1ac75659c440e9d737fb81d5a8f3f60cda48d041ed71c61adfcb5cb022026fbd30a651433778d4d94d774082ba66acd7dd1d43d8263e36972aba98c6a79\n,\n  \ntype\n: 2,\n  \ndomains\n: [\n    \n64c74b58966274583ebe2e177e8f53da090cecf91a8d21d173e1af48d3ea3f21\n,\n    \nf9df663ad9cd758eb1ae510d595a5f722b558e8176e576e62031fbe4053b3943\n\n    ],\n  \nexpiry\n: 1442044141,\n  \nlast_update\n: 1442044141,\n  \nupdate_proof_of_work\n: \n1:24:1509120749:[mimdata]::hyVUb0vRzJsxkZ4Q:0001tD3/\n,\n  \nupdate_signature\n: \n3046022100ce06189f3aea609a095aebb2a8ff4115af18c15abc0e84ff07ee7ba5687a3502022100bc7676c71e81208e179afc7fe0302ac1433ce22527d673ed291dd0965d4e5e58\n\n}\n\n\n\n\nTrustState Index Form Example\n\n\n{\n  \nfingerprint\n: \nedb4e3da4e8f1e99aba3743fc3de5a84f73e4fd32f5883759e743582a25cb466\n,\n  \ntarget\n: \n81b3c8d7ae3fa2b971e811834e61e4d6a30c246fb04ac309b267c1dc369cb902\n,\n  \ncreation\n: 1442041028,\n  \nlast_update\n: 1442099904,\n  \npage_number\n: 0 // Only appears on index form. Allows for faster queries.\n}\n\n\n\n\nFields\n\n\nFingerprint\n\n\nSee Board \n Fingerprint field.\n\n\nTarget\n\n\nThe target key (user) of the trust assignment.\n\n\nOwner\n\n\nSee Post \n Owner field.\n\n\nCreation\n\n\nSee Post \n Creation field.\n\n\nProofOfWork\n\n\nSee Post \n ProofOfWork field.\n\n\nSignature\n\n\nSee Post \n Signature field.\n\n\nType\n\n\nA value between 0 and 255. (uint8)\n\n\nType values\n\n\n0: Neutral trust state. This is assumed if no state is available. If you see this, this was reverted back from some other type of state.\n\n\n1: Trusted. Owner of this TrustState trusts the user with the key TargetKey.\n\n\n2: Distrusted. Owner of this TrustState has blocked the user with the key TargetKey.\n\n\nDomains\n\n\nAn array of board fingerprints, in which the user is declared to be in the provided trust state. You cannot trust an user in one board and distrust in another. If you give a domain, in anywhere that is not the domain provided, the trust is assumed to be neutral. If you do not give a domain, the trust is in all boards.\n\n\nExpiry\n\n\nThe UTC timestamp which declares when the trust expires. Can be empty. If empty, the trust does not expire.\n\n\nLastUpdate\n\n\nSee Board \n LastUpdate field.\n\n\nUpdateProofOfWork\n\n\nSee Board \n UpdateProofOfWork field.\n\n\nUpdateSignature\n\n\nSee Board \n UpdateSignature field.", 
            "title": "Entities"
        }, 
        {
            "location": "/objects/#entities", 
            "text": "These are the root level protocol objects that have their own endpoints.   Board  Thread  Post  Vote  Address  Key  TrustState   These are the sub-level protocol objects that do not have their endpoints, and only provided integrated to the objects encapsulating them. You cannot query them on their own.   BoardOwner (sub-entity of Board)  Protocol (sub-entity of Address)  Client (sub-entity of Address)  CurrencyAddress (sub-entity of Key)", 
            "title": "Entities"
        }, 
        {
            "location": "/objects/#board", 
            "text": "Boards are the Terminal top-level elements of the architecture. All posts belong to a board and a thread. Think of these as subreddits. They can have an owner, which is the person that created the board. This is the permanent moderator of the board. The permanent moderator can assign moderators for a limited timespan.  Board Object  This is the spec of the standard Board entity a Mim node will provide you. The order of these fields are undefined, it can come in any order.   Fingerprint (64 characters, ASCII string)  Name (Min 2, Max 255 characters, Unicode string)  Creation (Unix Epoch Time, UTC, int64)  ProofOfWork (Min 0, Max 1024 characters, ASCII string)  Signature (Min 0, Max 512 characters, ASCII string)  BoardOwners ( Mutable , Min 0 array of BoardOwner objects, max 100)  Description ( Mutable , Min 0, Max 65535 characters, Unicode string)  LastUpdate ( Mutable , Unix Epoch Time, UTC, int64)  UpdateProofOfWork ( Mutable , Min 0, Max 1024 characters, ASCII string)  UpdateSignature ( Mutable , Min 0, Max 512 characters, ASCII string)   Mutable fields in Board Object  'BoardOwners', 'Description', 'LastUpdate', 'UpdateProofOfWork', 'UpdateSignature'  Maximum uncompressed theoretical size  ~280 Kilobytes, assuming 100 (max) board owners, and assuming 65535 (max) characters on description, all characrers 4 bytes each (unicode max). On average, boards will likely have 1-2 owners, and 500-600 characters description. If average, ~20 kilobytes. Variance is moderate, but be ready to handle extreme cases.  Board Example  {\n   fingerprint :  ea7d8e81e18e3791e0e89a4ebaba64c92c3f0f3c03c3057e2ef5e9fcb7f13891 ,\n   name :  My awesome board ,\n   creation : 1442040412,\n   proof_of_work :  1:23:1509120719:[mimdata]::xUEBZA89/o7EZwtg:000000000000000000000000000000000GHiK ,\n   signature :  30450221008829563cc1ac75659c440e9d737fb81d5a8f3f60cda48d041ed71c61adfcb5cb022026fbd30a651433778d4d94d774082ba66acd7dd1d43d8263e36972aba98c6a79 ,\n   board_owners : [\n    {\n       key_fingerprint :  f1c4f90dd4a45bdb83b47e04e158065b9c7c867ffd44ea925c1301ad6134f2bd ,\n       expiry :  ,\n       level : 2\n    }\n  ],\n   description :  This is where you get to explain what your board is about. ,\n   last_update : 1442044141,\n   update_proof_of_work :  1:24:1509120749:[mimdata]::hyVUb0vRzJsxkZ4Q:0001tD3/ ,\n   update_signature :  3046022100ce06189f3aea609a095aebb2a8ff4115af18c15abc0e84ff07ee7ba5687a3502022100bc7676c71e81208e179afc7fe0302ac1433ce22527d673ed291dd0965d4e5e58 \n}  Board Index Form Example  This form is the compressed form of the full object. It is provided in the index so as to allow the requester to decide whether it wants to request this object or not. If the requester thinks this object is useful, it needs to request the full object to be able to do anything with it.  {\n   fingerprint :  edb4e3da4e8f1e99aba3743fc3de5a84f73e4fd32f5883759e743582a25cb466 ,\n   creation : 1442041028,\n   last_update : 1442099904,\n   page_number : 0 // Only appears on index form. Allows for faster queries.\n}  Fields  Fingerprint  SHA256 hash of the entirety of the object. See entity concepts for how to come up and how to verify this.  Of all the three calculations (proof of work, signature, fingerprint), this should happen last.  Name  User-visible portion of the board. Between 2 and 255 unicode characters. Do not assume this always means 255 bytes! A unicode character can be and is often larger than a byte.  Creation  Creation date and time in UTC as an int64. This is the standard UNIX Epoch Time.  ProofOfWork  This field provides proof of work. To see how to create and verify this, see the relevant section in the Entity Concepts topic.  Signature  This field provides signatures. To see how to create and verify this, see the relevant section in the Entity Concepts topic.  Of all the three calculations (proof of work, signature, fingerprint), this should happen second.  BoardOwners  An array of BoardOwner objects. Can be empty. Updatable.  When you convert this to a string, concat everything without any sort of delineation.  Description  Description of the board. Admin of the board can update this.  LastUpdate  Update date and time in UTC as an int64. This is the standard UNIX Epoch Time.  UpdateProofOfWork  This field provides proof of work. To see how to create and verify this, see the relevant section in the Entity Concepts topic.  UpdateSignature  This field provides signatures. To see how to create and verify this, see the relevant section in the Entity Concepts topic.   BoardOwner (sub-entity of Board)  BoardOwner entities go into the updatable 'BoardOwners' field of a board. They are not distributed separately, but embedded into 'Board' objects. There is no upper limit on how many owners a board can have. A board can also have no owners, in which case it is not moderated by mods but by community by means of voting.  BoardOwner Object   KeyFingerprint (64 characters, ASCII string)  Expiry (Unix Epoch Time, UTC, int64, or empty)  Level (uint8. A number between 0-255)   Fields  KeyFingerprint  This is the fingerprint of the key the ownership is associated to.  Expiry  When the ownership expires. Can be empty. If empty, ownership lasts until revoked by the admin of the board.  Level  A number between 0 and 255. Values are given below:  2: Admin. Can add and remove mods. Can remove itself. Can moderate.  1: Mod. Cannot add or remove mods. Cannot remove itself. Can moderate.  0: Abdicated admin. If an admin wants to remove itself, he or she sets his own level value to 0. Abdication is irrevocable.", 
            "title": "Board"
        }, 
        {
            "location": "/objects/#thread", 
            "text": "Threads are a collection of posts. They have a header, which is the name of the thread. They can either be text-based, in which the user writes some text as the discussion starter, or link-based, in which the thread is a link to an external page.  Thread Object   Fingerprint (64 characters, ASCII string)  Board (64 characters, ASCII string)  Name (Min 2, Max 255 characters, Unicode string)  Body (Min 0, Max 65535 characters, Unicode string)  Link (Min 0, Max 5000 characters, Unicode string)  Owner (0 or 64 characters, ASCII string)  Creation (Unix Epoch Time, UTC, int64)  ProofOfWork (Min 0, Max 1024 characters, ASCII string)  Signature (Min 0, Max 512 characters, ASCII string)   Maximum uncompressed theoretical size  ~280 Kilobytes, assuming 65535 (max) characters on body, 255 on name, and 5000 on link, all characrers 4 bytes each (unicode max). This wildly varies, be ready to handle extreme cases.  Thread Example  {\n   fingerprint :  ea7d8e81e18e3791e0e89a4ebaba64c92c3f0f3c03c3057e2ef5e9fcb7f13891 ,\n   board :  14fc9b8593050a15ebdf2ebae13150315fa9b14e4e921b03f9912c6a2560b8f2 ,\n   name :  My awesome thread ,\n   body :  This is the body of the thread. ,\n   link :  http://www.zombo.com ,\n   owner :  f1c4f90dd4a45bdb83b47e04e158065b9c7c867ffd44ea925c1301ad6134f2bd ,\n   creation : 1442040412,\n   proof_of_work :  1:23:1509120719:[mimdata]::xUEBZA89/o7EZwtg:000000000000000000000000000000000GHiK ,\n   signature :  30450221008829563cc1ac75659c440e9d737fb81d5a8f3f60cda48d041ed71c61adfcb5cb022026fbd30a651433778d4d94d774082ba66acd7dd1d43d8263e36972aba98c6a79 ,\n}  Thread Index Form Example  {\n   fingerprint :  edb4e3da4e8f1e99aba3743fc3de5a84f73e4fd32f5883759e743582a25cb466 ,\n   board :  71f12bb2278e400d7fec0a40c1944df32fbd0c6e91d10c7ec5e6bbf194b0f4e8 ,\n   creation : 1442041028,\n   page_number : 0 // Only appears on index form. Allows for faster queries.\n}  Fields  Fingerprint  SHA256 hash of the entirety of the object. To come up with the fingerprint, convert all the fields except itself into and unicode string and run SHA256 hash over it.  Of all the three calculations (proof of work, signature, fingerprint), this should happen last.  Board  Fingerprint of the board this thread belongs to.  Name  Name of the thread. Between 2 and 255 unicode characters.  Body  Main text. Between 0 and 65535 characters unicode string. Can be empty.  Link  The address the thread links to. Between 0 and 65535 characters unicode string. Can be empty.  Owner  Fingerprint of a Key that owns this. Can be empty.  Creation  See Board   Creation field.  ProofOfWork  This field provides a a Hashcash token and its signature. To generate the string that goes into Hashcash, convert all fields except 'Fingerprint' and itself to a unicode string, concatenate them, and run Hashcash over with the configuration options. See 'Entity Concepts' section for more info.  Signature  ECDSA signature of all fields except 'Fingerprint' and itself. Can be empty. For the exact ECDSA signature algorithm, please read on. [todo]", 
            "title": "Thread"
        }, 
        {
            "location": "/objects/#post", 
            "text": "Posts are comments written by users of the protocol. They can be replies directly to the thread, or to another post.  Post Object   Fingerprint (64 characters, ASCII string)  Board (64 characters, ASCII string)  Thread (64 characters, ASCII string)  Parent (64 characters, ASCII string)  Body (Min 0, Max 65535 characters, Unicode string)  Owner (0 or 64 characters, ASCII string)  Creation (Unix Epoch Time, UTC, int64)  ProofOfWork (Min 0, Max 1024 characters, ASCII string)  Signature (Min 0, Max 512 characters, ASCII string)   Maximum uncompressed theoretical size  ~280 Kilobytes, assuming 65535 (max) characters on body, all characters 4 bytes each (unicode max). This wildly varies, so while average post length is 1000~ characters and is mostly ASCII (1 bytes), be ready to handle extreme cases.  Post Example  {\n   fingerprint :  ea7d8e81e18e3791e0e89a4ebaba64c92c3f0f3c03c3057e2ef5e9fcb7f13891 ,\n   board :  64c74b58966274583ebe2e177e8f53da090cecf91a8d21d173e1af48d3ea3f21 ,\n   thread :  f1c4f90dd4a45bdb83b47e04e158065b9c7c867ffd44ea925c1301ad6134f2bd ,\n   parent :  f1c4f90dd4a45bdb83b47e04e158065b9c7c867ffd44ea925c1301ad6134f2bd , // if same as board, it's a direct post to the thread.\n   body :  This is my post. ,\n   owner :  623429db9c6e9bd441b5d6ceaaeeb80a1066f4a0cdbc83722bb970f67700b22f ,\n   creation : 1442040412,\n   proof_of_work :  1:23:1509120719:[mimdata]::xUEBZA89/o7EZwtg:000000000000000000000000000000000GHiK ,\n   signature :  30450221008829563cc1ac75659c440e9d737fb81d5a8f3f60cda48d041ed71c61adfcb5cb022026fbd30a651433778d4d94d774082ba66acd7dd1d43d8263e36972aba98c6a79 ,\n}  Post Index Form Example  {\n   fingerprint :  edb4e3da4e8f1e99aba3743fc3de5a84f73e4fd32f5883759e743582a25cb466 ,\n   board :  71f12bb2278e400d7fec0a40c1944df32fbd0c6e91d10c7ec5e6bbf194b0f4e8 ,\n   thread :  81b3c8d7ae3fa2b971e811834e61e4d6a30c246fb04ac309b267c1dc369cb902 ,\n   creation : 1442041028,\n   page_number : 0 // Only appears on index form. Allows for faster queries.\n}  Fields  Fingerprint  See Thread   Fingerprint field.  Board  Fingerprint of the board this post belongs to.  Thread  Fingerprint of the thread this post belongs to.  Parent  Fingerprint of the entity that is the ancestor to this post.  Body  See Thread   Body field.  Owner  See Thread   Owner field.  Creation  See Board   Creation field.  ProofOfWork  See Thread   ProofOfWork field.  Signature  See Thread   Signature field.", 
            "title": "Post"
        }, 
        {
            "location": "/objects/#vote", 
            "text": "Vote objects are emitted when people vote on threads or posts. These are signed by user's private keys, so the user can vote only once on a certain entity. If user's vote changes, his or her vote will update accordingly across the network.  Vote Object   Fingerprint (64 characters, ASCII string)  Board (64 characters, ASCII string)  Thread (64 characters, ASCII string)  Target (64 characters, ASCII string)  Owner (64 characters, ASCII string)  Creation (Unix Epoch Time, UTC, int64)  ProofOfWork (Min 0, Max 1024 characters, ASCII string)  Signature (Min 0, Max 512 characters, ASCII string)  Type ( Mutable , uint8. A number between 0-255)  LastUpdate ( Mutable , Unix Epoch Time, UTC, int64)  UpdateProofOfWork ( Mutable , Min 0, Max 1024 characters, ASCII string)  UpdateSignature ( Mutable , Min 0, Max 512 characters, ASCII string)   Mutable fields in Vote Object  'Type', 'LastUpdate', 'UpdateProofOfWork', 'UpdateSignature'  Maximum uncompressed theoretical size  ~1 Kilobytes.  Vote Example  {\n   fingerprint :  ea7d8e81e18e3791e0e89a4ebaba64c92c3f0f3c03c3057e2ef5e9fcb7f13891 ,\n   board :  64c74b58966274583ebe2e177e8f53da090cecf91a8d21d173e1af48d3ea3f21 ,\n   thread :  f1c4f90dd4a45bdb83b47e04e158065b9c7c867ffd44ea925c1301ad6134f2bd ,\n   target :  f1c4f90dd4a45bdb83b47e04e158065b9c7c867ffd44ea925c1301ad6134f2bd ,\n   owner :  623429db9c6e9bd441b5d6ceaaeeb80a1066f4a0cdbc83722bb970f67700b22f ,\n   creation : 1442040412,\n   proof_of_work :  1:23:1509120719:[mimdata]::xUEBZA89/o7EZwtg:000000000000000000000000000000000GHiK ,\n   signature :  30450221008829563cc1ac75659c440e9d737fb81d5a8f3f60cda48d041ed71c61adfcb5cb022026fbd30a651433778d4d94d774082ba66acd7dd1d43d8263e36972aba98c6a79 ,\n   type : 1,\n   last_update : 1442044141,\n   update_proof_of_work :  1:24:1509120749:[mimdata]::hyVUb0vRzJsxkZ4Q:0001tD3/ ,\n   update_signature :  3046022100ce06189f3aea609a095aebb2a8ff4115af18c15abc0e84ff07ee7ba5687a3502022100bc7676c71e81208e179afc7fe0302ac1433ce22527d673ed291dd0965d4e5e58 \n}  Vote Index Form Example  {\n   fingerprint :  edb4e3da4e8f1e99aba3743fc3de5a84f73e4fd32f5883759e743582a25cb466 ,\n   board :  71f12bb2278e400d7fec0a40c1944df32fbd0c6e91d10c7ec5e6bbf194b0f4e8 ,\n   thread :  81b3c8d7ae3fa2b971e811834e61e4d6a30c246fb04ac309b267c1dc369cb902 ,\n   target :  81b3c8d7ae3fa2b971e811834e61e4d6a30c246fb04ac309b267c1dc369cb902 ,\n   creation : 1442041028,\n   last_update : 1442099904,\n   page_number : 0 // Only appears on index form. Allows for faster queries.\n}  Fields  Fingerprint  See Board   Fingerprint field.  Board  See Post   Board field.  Thread  See Post   Thread field.  Target  The target of this vote. Can be post or a thread.  Owner  See Post   Owner field.  Creation  See Post   Creation field.  ProofOfWork  See Post   ProofOfWork field.  Signature  See Post   Signature field.  Type  A value between 0 and 255. (uint8)  Type values  0: Neutral vote. This is assumed if no vote is available. If you see this, this was reverted back from some other type of vote.  1: Upvote (Applicable to Posts, Threads)  2: Downvote (Applicable to Posts, Threads)  3: Pinned (Applicable to Posts, Threads)  4: Blocked (Applicable to Posts, Threads, Boards)  LastUpdate  See Board   LastUpdate field.  UpdateProofOfWork  See Board   UpdateProofOfWork field.  UpdateSignature  See Board   UpdateSignature field.", 
            "title": "Vote"
        }, 
        {
            "location": "/objects/#address", 
            "text": "Address objects are IP addresses running a Mim client. They can be of a certain type, or be running a protocol extension. You decide whether to connect to these with protocol version and with the extensions they are running.  Address Object   Location (Max 2500 characters ASCII string)  Sublocation (Max 2500 characters ASCII string)  LocationType (6 or 4 or 3, single integer)  Port (uint16. A number between 0-65535)  Type ( Mutable , uint8. A number between 0-255)  LastOnline ( Mutable , Unix Epoch Time, UTC, int64)  Protocol ( Mutable , Protocol object)  Client ( Mutable , Client object)   Mutable fields in Address Object  Address fields are mutable only when directly connected to that address. In other words, addresses are collected from the network only once. An update based on the data coming from another node which is not at the address is not permitted. This is so as to mitigate an attack vector in which the attacker cuts off or encourages the connections (DDoS) to an address by changing the details used to make dispatch decisions on other nodes.  'Type', 'LastOnline', 'Protocol', 'Client'  Maximum uncompressed theoretical size  ~8 Kilobytes, assuming 100 (max) extensions each 64 characters ASCII (max), 255 characters unicode as client name (max). Average number of extensions is likely 0-1. Average length of client name is likely 7-10 bytes. If average, ~0.5 Kilobytes.  Address Example  {\n   location :  1.2.3.4 ,\n   sublocation :  ,\n   location_type : 4,\n   port : 23432,\n   type : 2,\n   last_online : 1442044141,\n   protocol : {\n     version_major : 0,\n     version_minor : 1,\n     extensions : []\n  },\n   client : {\n     version_major : 2,\n     version_minor : 0,\n     version_patch : 0,\n     name :  Aether \n  }\n}  Address Index Form Example  The index form of address is the address entity itself.  {\n   location :  1.2.3.4 ,\n   sublocation :  ,\n   location_type : 4,\n   port : 23432,\n   type : 2,\n   last_online : 1442044141,\n   protocol : {\n     version_major : 0,\n     version_minor : 1,\n     extensions : []\n  },\n   client : {\n     version_major : 2,\n     version_minor : 0,\n     version_patch : 0,\n     name :  Aether \n  }\n}  Fields  Location  Ip address, v4 or v6 (127.0.0.1) or root URL. (http://www.example.com)  Sublocation  If location is URL, this is the non-root part. i.e. (my_awesome_static_node)  Combined with the root URL above, this means the node is at http://www.example.com/my_awesome_static_node  LocationType  The type of IP address. It can either be 4 or 6 or 3. 3 means it's a URL.  Port  The Mim port of the address. An uint16 number between 0-65535.  Type  Mim type of the address.  Type values  0: Static. This node is 'frozen'. It will not respond to filter queries, just to show all requests. An example of this node is a static website.  1: Ephemeral. This node is likely not going to be there when asked back. This is useful for a computing device to declare itself as ephemeral. An example of an ephemeral computing device would be a phone, or a tablet. These devices just pull data, read, and leave. They can write, so if a 'new content' signal is received from that node, it should be acted upon as soon as possible. How this signal will change the behaviour of the remote computer is left to the client implementation.  2: Live. This is a normal computer that stays online for durations longer than a few minutes. This is the default setting.  LastOnline  The date this node was last connected to.  Protocol  Protocol object which declares the protocol the address is running.   Protocol (sub-entity of Address)  Defines the protocol version and extensions the client is running. Protocol extensions are extensions to the Mim protocol where additional features and entities can be added.  Protocol Object   VersionMajor (uint8)  VersionMinor (uint16)  Extensions (array of strings, max 64 characters long each, ASCII max 100 extensions)   Fields  VersionMajor  Major version of the Mim protocol running on this address.  VersionMinor  Minor version of the Mim protocol running on this address.  Extensions  The array of strings, each of which define an extension to the Mim protocol. Max 100 extensions. Each string is maximum 64 characters ASCII.   Client (sub-entity of Address)  Defines the client that is running on this address. This object is empty if the node is static.  Client Object   VersionMajor (uint8)  VersionMinor (uint16)  VersionPatch (uint16)  ClientName (Max 255 characters Unicode)   Fields  VersionMajor  Major version of the client running on this address.  VersionMinor  Minor version of the client running on this address.  VersionPatch  Minor version of the client running on this address.  ClientName  Name of the client running on this node. Max 255 characters Unicode.", 
            "title": "Address"
        }, 
        {
            "location": "/objects/#key", 
            "text": "Keys represent unique users. Having a key is optional, i.e. you can write posts anonymously. However, the nodes might reject to receive these posts written in such a manner. If you do not have a key, you cannot vote.  Key Object   Fingerprint  (64 characters, ASCII string)  Type (256 characters, ASCII String)  Key (Max 65536 characters ASCII string)  Name (Max 64 characters Unicode)  Creation (Unix Epoch Time, UTC, int64)  ProofOfWork (Min 0, Max 1024 characters, ASCII string)  Signature (Min 0, Max 512 characters, ASCII string)  CurrencyAddresses ( Mutable , Array of CurrencyAddress, Max 10.)  Info ( Mutable , Max 1024 characters Unicode.)  LastUpdate ( Mutable , Unix Epoch Time, UTC, int64)  UpdateProofOfWork ( Mutable , Min 0, Max 1024 characters, ASCII string)  UpdateSignature ( Mutable , Min 0, Max 512 characters, ASCII string)   Mutable fields in Key Object  'CurrencyAddresses', 'Info', 'LastUpdate', 'UpdateProofOfWork', 'UpdateSignature'  Maximum uncompressed theoretical size  ~80 Kilobytes, assuming 10 (max) currency addresses with all their values at mex, 65535 characters ASCII (max) at key and all other values are maxed.. Length of the key used by default is 512 characters ASCII. Average number of currency addresses for a key is 0-1 If average, ~6 Kilobytes.  Key Example  {\n   fingerprint :  ea7d8e81e18e3791e0e89a4ebaba64c92c3f0f3c03c3057e2ef5e9fcb7f13891 ,\n   type :  secp256k1 ,\n   name :  burak ,\n   key :  04da41af852dad151094de0e84a7c8a111cf93d56a2028c8400a1e9f9e37adffd4328a256228cc30387af52e507e33c28cf1accfda524800cdd5f17845ebc63168 ,\n   creation : 1442040412,\n   proof_of_work :  1:23:1509120719:[mimdata]::xUEBZA89/o7EZwtg:000000000000000000000000000000000GHiK ,\n   signature :  30450221008829563cc1ac75659c440e9d737fb81d5a8f3f60cda48d041ed71c61adfcb5cb022026fbd30a651433778d4d94d774082ba66acd7dd1d43d8263e36972aba98c6a79 ,\n   currency_addresses : [\n    {\n       currency_code :  XDG ,\n       address :  ea7d8e81e18e3791e0e89a4ebaba64c92c3f0f3c03c3057e2ef5e9fcb7f13891 \n    }\n  ],\n   info :  This is the key information. ,\n   last_update : 1442044141,\n   update_proof_of_work :  1:24:1509120749:[mimdata]::hyVUb0vRzJsxkZ4Q:0001tD3/ ,\n   update_signature :  3046022100ce06189f3aea609a095aebb2a8ff4115af18c15abc0e84ff07ee7ba5687a3502022100bc7676c71e81208e179afc7fe0302ac1433ce22527d673ed291dd0965d4e5e58 \n}  Key Index Form Example  The index form of address is the address entity itself.  {\n   fingerprint :  edb4e3da4e8f1e99aba3743fc3de5a84f73e4fd32f5883759e743582a25cb466 ,\n   creation : 1442041028,\n   last_update : 1442099904,\n   page_number : 0 // Only appears on index form. Allows for faster queries.\n}  Fingerprint  See Board   Fingerprint field.  Type  The type of the key, a string field, such as 'RSA2048'. There are no defined values of this field. Whatever you put there, make sure all other clients can decipher it. If this type is indecipherable to a client, it is required for the client to make a best-effort attempt to validate the key.  Key  The key itself.  Name  The user name of the person who owns the key.  Creation  See Thread   Creation field.  ProofOfWork  See Thread   ProofOfWork field.  Signature  See Thread   Signature field.  CurrencyAddresses  An array of CurrencyAddress objects. Maximum 10 objects.  Info  Ideally, some information about the owner of the key, alternative contact methods etc.  LastUpdate  See Board   LastUpdate field.  UpdateProofOfWork  See Board   UpdateProofOfWork field.  UpdateSignature  See Board   UpdateSignature field.   CurrencyAddress (sub-entity of Key)  Defines a currency where the user can be sent money out-of-band. Mim does not handle monetary transactions.  CurrencyAddress Object   CurrencyCode (Max 5 characters ASCII string, ISO 4217)  Address (Max 1024 characters ASCII string)   Fields  CurrencyCode  ISO4217 Currency code of the currency in this address. The currencies not defined in ISO4217 should be based on consensus. If you are dealing with a cryptocurrency, the recommendation is to use X at the beginning and 2 letters for the currency. For example, Bitcoin would be XBT.  Address  The currency address of the keyholder in this currency.", 
            "title": "Key"
        }, 
        {
            "location": "/objects/#truststate", 
            "text": "TrustState objects are declarations of trust of an user for another. If an user trusts, or distrusts another, it emits a TrustState. If the user changes an existing TrustState to neutral, it updates the state with a 'neutral'.  TrustState Object   Fingerprint (64 characters, ASCII string)  Target (64 characters, ASCII string)  Owner (64 characters, ASCII string)  Creation (Unix Epoch Time, UTC, int64)  ProofOfWork (Min 0, Max 1024 characters, ASCII string)  Signature (Min 0, Max 512 characters, ASCII string)  Type ( Mutable , uint8. A number between 0-255)  Domains ( Mutable , Min 0, max 100 array of Board fingerprints)  Expiry ( Mutable , Unix Epoch Time, UTC, int64)  LastUpdate ( Mutable , Unix Epoch Time, UTC, int64)  UpdateProofOfWork ( Mutable , Min 0, Max 1024 characters, ASCII string)  UpdateSignature ( Mutable , Min 0, Max 512 characters, ASCII string)   Mutable fields in TrustState Object  'Type', 'Domains', 'Expiry' 'LastUpdate', 'UpdateProofOfWork', 'UpdateSignature'  Maximum uncompressed theoretical size  ~7 Kilobytes, assuming 100 (max) domains. Average number of domains is likely 1-2. If average, ~1 Kilobytes.  TrustState Example  {\n   fingerprint :  ea7d8e81e18e3791e0e89a4ebaba64c92c3f0f3c03c3057e2ef5e9fcb7f13891 ,\n   target :  f1c4f90dd4a45bdb83b47e04e158065b9c7c867ffd44ea925c1301ad6134f2bd ,\n   owner :  623429db9c6e9bd441b5d6ceaaeeb80a1066f4a0cdbc83722bb970f67700b22f ,\n   creation : 1442040412,\n   proof_of_work :  1:23:1509120719:[mimdata]::xUEBZA89/o7EZwtg:000000000000000000000000000000000GHiK ,\n   signature :  30450221008829563cc1ac75659c440e9d737fb81d5a8f3f60cda48d041ed71c61adfcb5cb022026fbd30a651433778d4d94d774082ba66acd7dd1d43d8263e36972aba98c6a79 ,\n   type : 2,\n   domains : [\n     64c74b58966274583ebe2e177e8f53da090cecf91a8d21d173e1af48d3ea3f21 ,\n     f9df663ad9cd758eb1ae510d595a5f722b558e8176e576e62031fbe4053b3943 \n    ],\n   expiry : 1442044141,\n   last_update : 1442044141,\n   update_proof_of_work :  1:24:1509120749:[mimdata]::hyVUb0vRzJsxkZ4Q:0001tD3/ ,\n   update_signature :  3046022100ce06189f3aea609a095aebb2a8ff4115af18c15abc0e84ff07ee7ba5687a3502022100bc7676c71e81208e179afc7fe0302ac1433ce22527d673ed291dd0965d4e5e58 \n}  TrustState Index Form Example  {\n   fingerprint :  edb4e3da4e8f1e99aba3743fc3de5a84f73e4fd32f5883759e743582a25cb466 ,\n   target :  81b3c8d7ae3fa2b971e811834e61e4d6a30c246fb04ac309b267c1dc369cb902 ,\n   creation : 1442041028,\n   last_update : 1442099904,\n   page_number : 0 // Only appears on index form. Allows for faster queries.\n}  Fields  Fingerprint  See Board   Fingerprint field.  Target  The target key (user) of the trust assignment.  Owner  See Post   Owner field.  Creation  See Post   Creation field.  ProofOfWork  See Post   ProofOfWork field.  Signature  See Post   Signature field.  Type  A value between 0 and 255. (uint8)  Type values  0: Neutral trust state. This is assumed if no state is available. If you see this, this was reverted back from some other type of state.  1: Trusted. Owner of this TrustState trusts the user with the key TargetKey.  2: Distrusted. Owner of this TrustState has blocked the user with the key TargetKey.  Domains  An array of board fingerprints, in which the user is declared to be in the provided trust state. You cannot trust an user in one board and distrust in another. If you give a domain, in anywhere that is not the domain provided, the trust is assumed to be neutral. If you do not give a domain, the trust is in all boards.  Expiry  The UTC timestamp which declares when the trust expires. Can be empty. If empty, the trust does not expire.  LastUpdate  See Board   LastUpdate field.  UpdateProofOfWork  See Board   UpdateProofOfWork field.  UpdateSignature  See Board   UpdateSignature field.", 
            "title": "TrustState"
        }, 
        {
            "location": "/apigeneral/", 
            "text": "API\n\n\nThis is the API you can use to speak to other nodes. This document gives you a comprehensive understanding of the core concepts of speaking to Mim nodes.\n\n\n\n\nMethods\n\n\nResponses\n\n\nFilters\n\n\nMinimum Results Policy\n\n\nEndpoints\n\n\n\n\nMethods\n\n\nYou can use the two HTTP verbs to be able to communicate with Mim nodes.\n\n\nGET\n\n\nWhen you do a get request to an endpoint of the node, you cannot ask for any specific object. The node will determine what you will receive. The node is can to serve you a truncated result, or a cached one to reduce its own CPU or bandwidth usage, or not do any of thethose things.\n\n\nPOST\n\n\nWhen you do a post request, you identify yourself as a Mim node by sending your ID and connection address. This makes you 'join' the network, and other people will start to connect to you, should they want to do so. Doing this on any endpoint (and therefore providing your address for others to connect to) gives you the ability to request specific entities, timestamps, etc.\n\n\nResponses\n\n\nThe response is be paginated if needed, and in JSON format. Besides the response body, you receive a HTTP status code. There are three codes possible.\n\n\nHTTP 200 OK\n\n\nReturned when your request succeeds. The body of this request should be the answer you requested.\n\n\nHTTP 400 Bad request\n\n\nYou will receive this if your request is malformed, or otherwise unserviceable.\n\n\nHTTP 404 Not found\n\n\nReturned when the content you requested isn't available.\n\n\nIf you get a 404 trying to get a new page of the result, you have reached to the end of the content provided by pagination. If the reply you have received had 18 pages, and you are trying to reach the 19th page, you will receive an 204 on the 19th page, because the answer will be empty.\n\n\nHTTP 405 Method not allowed\n\n\nYou will receive this if you try to do a POST request on a node that does not support it, such as static nodes.\n\n\nHTTP 429 Too many requests\n\n\nYou can receive this on any endpoint if the remote node becomes too busy.\n\n\nFilters\n\n\nFor certain endpoints, you can request the result to be filtered (modified) in a certain way. This is what allows you to request a specific object by fingerprint, or keep in sync with incremental updates and else.\n\n\nGiven below are the filters. If an endpoint supports any of those, it will be noted in the documentation for that endpoint.\n\n\nGET\n\n\nCache\n\n\nAll Mim nodes keep (or generate at the point of request) a series of caches to provide other nodes with pre-packaged answers to common queries. This allows nodes to conserve their CPU cycles.\n\n\nThe way you bootstrap (work yourself up to the most up-to-date state) in Mim is that you seek caches of objects from nodes. There are three types of caches.\n\n\nEvery endpoint (board, thread, post, etc.) will have their result cached every day, and retains last 7 copies of these. Each of these days' caches contain the entities that were created or updated that day. When a cache becomes more than 7 days old, the node does no longer have a responsibility to carry that cache, though it might decide to keep a longer duration of past caches if it chooses to do so. These caches are not modified after they are created. Each cache includes a link to the past cache, and if you do a GET on any entity endpoint, you will get the most current cache.\n\n\n\n\n\nAll in all, with the current 7 endpoints, 7 caches each means 49 caches will be kept, plus one weekly cache for index, bringing it to 50 total caches. The first 49 caches are never modified after creation up until the point they are deleted, while the remaining one is updated every day.\n\n\nThe cache filter allows the asking node to specify which day's cache it wants.\n\n\nPOST\n\n\nTimestamp\n\n\nIf you provide a timestamp, you will receive the objects that were added or updated after the timestamp. Can only be used if the \nfingerprints\n filter is not provided.\n\n\nFingerprints\n\n\nIf you provide a fingerprint, or an array of fingerprints, you will receive the objects you have requested, so long as the objects are available on the remote node. Can only be used if the \ntimestamp\n filter is not provided.\n\n\nEmbeds\n\n\nCertain things can be embedded into endpoint results under certain conditions. For example, in Boards endpoint, you can ask threads and keys for these threads to be embedded. Can either be used with a \ntimestamp\n or with a \nfingerprints\n filter.\n\n\nBy default, these values are only provided as fingerprints on the endpoint. If you embed these values, they will be provided as full objects. These embedded objects are not actually inserted into the main object, rather, they are provided as their own objects and they will count against the standard results policy.\n\n\nMinimum Results Policy\n\n\nIf an endpoint returns objects, the standard policy of all unfiltered results are that they provide last 7 days' worth of objects ordered by most recent. Minimum response is 10,000 objects or 7 days, whichever is more.\n\n\nFor example, if there were 2400 new or updated (mutable fields changing is considered an update) objects in the last 7 days, the response will still be 10,000 objects, but the remaining 7600 of them will be older than 7 days. The only way you can get an answer that is less than 10,000 objects is that the remote does not have 10,000 objects in its store, in total.\n\n\nIf an endpoint returns embedded objects, the object embeds are provided as their own objects. Embeds are based on certain criteria (i.e. boards endpoint with keys embed will only return keys which are used in the boards that are being provided), so there are no minimum or maximums on the amount of embeds provided.\n\n\nIndex has a special minimum results policy, since it only provides an index, and not the object bodies. At a minimum, index should provide, a week's worth of or 10,000 boards, threads and posts each, and a week's worth of, or 5000 for votes, keys, addresses and truststates each, whichever is more.\n\n\nThe policy provided here is a guidance, and is merely the default settings. These values below should be able to be set by the end user within reasonable limits. There are certain cases where having a lower minimum entity response count makes sense, such as a mobile device.\n\n\nHowever, be courteous: if your program does not 'play nice', the other nodes are free to block you out, too. You should be contributing to the network by providing objects when requested in a reasonable quantity and depth.\n\n\nThe spec requires that the nodes communicate how many results they are returning in each type at the beginning of the response.\n\n\nEndpoints\n\n\nRelevant page", 
            "title": "API"
        }, 
        {
            "location": "/apigeneral/#api", 
            "text": "This is the API you can use to speak to other nodes. This document gives you a comprehensive understanding of the core concepts of speaking to Mim nodes.   Methods  Responses  Filters  Minimum Results Policy  Endpoints", 
            "title": "API"
        }, 
        {
            "location": "/apigeneral/#methods", 
            "text": "You can use the two HTTP verbs to be able to communicate with Mim nodes.  GET  When you do a get request to an endpoint of the node, you cannot ask for any specific object. The node will determine what you will receive. The node is can to serve you a truncated result, or a cached one to reduce its own CPU or bandwidth usage, or not do any of thethose things.  POST  When you do a post request, you identify yourself as a Mim node by sending your ID and connection address. This makes you 'join' the network, and other people will start to connect to you, should they want to do so. Doing this on any endpoint (and therefore providing your address for others to connect to) gives you the ability to request specific entities, timestamps, etc.", 
            "title": "Methods"
        }, 
        {
            "location": "/apigeneral/#responses", 
            "text": "The response is be paginated if needed, and in JSON format. Besides the response body, you receive a HTTP status code. There are three codes possible.  HTTP 200 OK  Returned when your request succeeds. The body of this request should be the answer you requested.  HTTP 400 Bad request  You will receive this if your request is malformed, or otherwise unserviceable.  HTTP 404 Not found  Returned when the content you requested isn't available.  If you get a 404 trying to get a new page of the result, you have reached to the end of the content provided by pagination. If the reply you have received had 18 pages, and you are trying to reach the 19th page, you will receive an 204 on the 19th page, because the answer will be empty.  HTTP 405 Method not allowed  You will receive this if you try to do a POST request on a node that does not support it, such as static nodes.  HTTP 429 Too many requests  You can receive this on any endpoint if the remote node becomes too busy.", 
            "title": "Responses"
        }, 
        {
            "location": "/apigeneral/#filters", 
            "text": "For certain endpoints, you can request the result to be filtered (modified) in a certain way. This is what allows you to request a specific object by fingerprint, or keep in sync with incremental updates and else.  Given below are the filters. If an endpoint supports any of those, it will be noted in the documentation for that endpoint.  GET  Cache  All Mim nodes keep (or generate at the point of request) a series of caches to provide other nodes with pre-packaged answers to common queries. This allows nodes to conserve their CPU cycles.  The way you bootstrap (work yourself up to the most up-to-date state) in Mim is that you seek caches of objects from nodes. There are three types of caches.  Every endpoint (board, thread, post, etc.) will have their result cached every day, and retains last 7 copies of these. Each of these days' caches contain the entities that were created or updated that day. When a cache becomes more than 7 days old, the node does no longer have a responsibility to carry that cache, though it might decide to keep a longer duration of past caches if it chooses to do so. These caches are not modified after they are created. Each cache includes a link to the past cache, and if you do a GET on any entity endpoint, you will get the most current cache.   All in all, with the current 7 endpoints, 7 caches each means 49 caches will be kept, plus one weekly cache for index, bringing it to 50 total caches. The first 49 caches are never modified after creation up until the point they are deleted, while the remaining one is updated every day.  The cache filter allows the asking node to specify which day's cache it wants.  POST  Timestamp  If you provide a timestamp, you will receive the objects that were added or updated after the timestamp. Can only be used if the  fingerprints  filter is not provided.  Fingerprints  If you provide a fingerprint, or an array of fingerprints, you will receive the objects you have requested, so long as the objects are available on the remote node. Can only be used if the  timestamp  filter is not provided.  Embeds  Certain things can be embedded into endpoint results under certain conditions. For example, in Boards endpoint, you can ask threads and keys for these threads to be embedded. Can either be used with a  timestamp  or with a  fingerprints  filter.  By default, these values are only provided as fingerprints on the endpoint. If you embed these values, they will be provided as full objects. These embedded objects are not actually inserted into the main object, rather, they are provided as their own objects and they will count against the standard results policy.", 
            "title": "Filters"
        }, 
        {
            "location": "/apigeneral/#minimum-results-policy", 
            "text": "If an endpoint returns objects, the standard policy of all unfiltered results are that they provide last 7 days' worth of objects ordered by most recent. Minimum response is 10,000 objects or 7 days, whichever is more.  For example, if there were 2400 new or updated (mutable fields changing is considered an update) objects in the last 7 days, the response will still be 10,000 objects, but the remaining 7600 of them will be older than 7 days. The only way you can get an answer that is less than 10,000 objects is that the remote does not have 10,000 objects in its store, in total.  If an endpoint returns embedded objects, the object embeds are provided as their own objects. Embeds are based on certain criteria (i.e. boards endpoint with keys embed will only return keys which are used in the boards that are being provided), so there are no minimum or maximums on the amount of embeds provided.  Index has a special minimum results policy, since it only provides an index, and not the object bodies. At a minimum, index should provide, a week's worth of or 10,000 boards, threads and posts each, and a week's worth of, or 5000 for votes, keys, addresses and truststates each, whichever is more.  The policy provided here is a guidance, and is merely the default settings. These values below should be able to be set by the end user within reasonable limits. There are certain cases where having a lower minimum entity response count makes sense, such as a mobile device.  However, be courteous: if your program does not 'play nice', the other nodes are free to block you out, too. You should be contributing to the network by providing objects when requested in a reasonable quantity and depth.  The spec requires that the nodes communicate how many results they are returning in each type at the beginning of the response.", 
            "title": "Minimum Results Policy"
        }, 
        {
            "location": "/apigeneral/#endpoints", 
            "text": "Relevant page", 
            "title": "Endpoints"
        }, 
        {
            "location": "/endpoints/", 
            "text": "Endpoints\n\n\nThese endpoints provide you with the ability to get certain information from the remote node. In summary, \n/status\n provides you a way to check the status and accessibility of the remote. \n/intro\n gives you a way to be introduced to the node. Definition of 'being introduced' is to be in sync with a node. In addition, every entity in the network has their own endpoints that return objects of their respective types. Protocol extensions can add their own objects and endpoints with custom behaviour.\n\n\nAll of these endpoints support GET, thus should be accessible via a normal web browser. This is useful for debugging. If you want to connect to your node, simply access \nhttps://[ip-address-of-node]:[port]/[protocol-version]/[endpoint]\n. For more complex queries, you can use \nweb browser extensions\n that allow you to construct a POST request.\n\n\nAll connections between nodes are force-HTTPS. Any non-encrypted connection between the nodes are forbidden and should result in a 400 Bad request. The nodes should \nnot\n redirect HTTP queries to HTTPS, the queries should outright fail.\n\n\nUtility Endpoints\n\n\nThese endpoints provide you utilities. They do not map 1:1 to entities provided therein, but they are tasked with several higher-level tasks such as communicating the status of the node, providing you with an introduction, or bootstrapping off of a node.\n\n\n\n\nStatus\n\n\n\n\n\nStatus\n\n\nEndpoint:\n /status\n\n\nGET\n\n\nStatus is how you check whether a node is online, and is not too busy for you to connect. If you receive an 200 from a status, the node is online, and will be able to respond to you. If you receive a 429, the remote node is busy, and you might be better served connecting to some other node for the time being.\n\n\nThere is no body to this request.\n\n\nPOST\n\n\nIf the local nodes provides a Node header, the status endpoint responds with the remote node's Node header. The remote will also save the local to its database for possible future connections.\n\n\nFilters\n\n\nDoes not support any filters.\n\n\n\n\n\nEntity Endpoints\n\n\nAll of the objects in Mim, but not sub-objects, will have their endpoints. For example, \nBoard\n is the endpoint where you query and get board objects. Example request and responses can be found \nhere\n.\n\n\n\n\nBoards\n\n\nThreads\n\n\nPosts\n\n\nVotes\n\n\nKeys\n\n\nAddresses\n\n\nTrustStates\n\n\n\n\nEntity GET\n\n\nIf you do a GET on any entity endpoint, you will be given the objects of that endpoint in accordance with the standard results policy. This reply will be coming from a cache. See Usage Examples for the syntax of this reply.\n\n\n[entity]/index\n\n\nhttps://1.2.3.4:34821/v0/boards/index\n\n\nThis endpoint provides you with the list of caches for that endpoint. The remote can provide up to 1000 cache links in the responses section.\n\n\nEach of the cache responses will be approximately 0.15kb. The base schema is 0.7kb. Therefore, with 10000 caches, the maximum size of this response should be below 5mb.\n\n\nThe remote can also provide more than 10000 cache links without violating the protocol, but if the index response size is larger than what would be required for 1000 caches, the local, at its own discretion, can abort. The reason for this is that anything larger than that has a higher likelihood of a denial of service attack.\n\n\nIn the case you abort the caches index for whatever reason, you can access the last cache (detailed below) to access the last cache, which includes its own link, and the link to the prior cache. You can go backwards by following links one by one.\n\n\n\n\n\n[entity]/cache_[random_cache_id]/0.json\n\n\nExample: \nhttps://1.2.3.4:34821/v0/boards/cache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688/0.json\n\n\nThis returns you the first page of the cache you requested. An example of this response is available at the examples session. Each of these pages have the entities you want to have.\n\n\n[random_cache_id]\n is a SHA256 hash of a random string. It has no significance other than being unique and is not stored anywhere.\n\n\nExample [random_cache_id]: \ncache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688\n\n\n[entity]/cache_[random_cache_id]/index/0.json\n\n\nThis is where the index of this cache is. Each of these indexes will be based the cache, and they consist of index of that entire cache.\n\n\nAddresses do not have a cache, as the index form of Address is itself.\n\n\nFilters\n\n\nNo endpoint of the entity GET supports any filters.\n\n\nEntity POST\n\n\nPOST allows you to query the remote node using filters provided in each endpoint, if any.\n\n\nYou will receive the link of the first page of the pagination that includes your answer. This response will be kept alive for 30 minutes from the time of request, so you should be done downloading all the pages before then. See Usage Examples for the syntax of this reply.\n\n\nBoards\n\n\nEndpoint:\n /boards\n\n\nProvides board objects.\n\n\nFilters\n\n\nSupports \ntimestamp\n, \nfingerprints\n and \nembeds\n. The embeds are these:\n\n\n\n\nThreads\n\n\nKeys\n\n\n\n\nThreads\n\n\nEndpoint:\n /threads\n\n\nProvides thread objects.\n\n\nFilters\n\n\nSupports \ntimestamp\n, \nfingerprints\n and \nembeds\n. The embeds are these:\n\n\n\n\nPosts\n\n\nKeys\n\n\n\n\nPosts\n\n\nEndpoint:\n /posts\n\n\nProvides post objects.\n\n\nFilters\n\n\nSupports \ntimestamp\n, \nfingerprints\n and \nembeds\n. The embeds are these:\n\n\n\n\nKeys\n\n\nVotes\n\n\n\n\nVotes\n\n\nEndpoint:\n /votes\n\n\nProvides vote objects.\n\n\nFilters\n\n\nSupports \ntimestamp\n, \nfingerprints\n. Does not support \nembeds\n.\n\n\nKeys\n\n\nEndpoint:\n /keys\n\n\nProvides key objects.\n\n\nFilters\n\n\nSupports \ntimestamp\n, \nfingerprints\n. Does not support \nembeds\n.\n\n\nAddressses\n\n\nEndpoint:\n /addresses\n\n\nProvides address objects.\n\n\nFilters\n\n\nSupports \ntimestamp\n, \nfingerprints\n. Does not support \nembeds\n.\n\n\nTrustStates\n\n\nEndpoint:\n /truststates\n\n\nProvides trust state objects.\n\n\nFilters\n\n\nSupports \ntimestamp\n, \nfingerprints\n and \nembeds\n. The embeds are these:\n\n\n\n\nKeys", 
            "title": "Endpoints"
        }, 
        {
            "location": "/endpoints/#endpoints", 
            "text": "These endpoints provide you with the ability to get certain information from the remote node. In summary,  /status  provides you a way to check the status and accessibility of the remote.  /intro  gives you a way to be introduced to the node. Definition of 'being introduced' is to be in sync with a node. In addition, every entity in the network has their own endpoints that return objects of their respective types. Protocol extensions can add their own objects and endpoints with custom behaviour.  All of these endpoints support GET, thus should be accessible via a normal web browser. This is useful for debugging. If you want to connect to your node, simply access  https://[ip-address-of-node]:[port]/[protocol-version]/[endpoint] . For more complex queries, you can use  web browser extensions  that allow you to construct a POST request.  All connections between nodes are force-HTTPS. Any non-encrypted connection between the nodes are forbidden and should result in a 400 Bad request. The nodes should  not  redirect HTTP queries to HTTPS, the queries should outright fail.", 
            "title": "Endpoints"
        }, 
        {
            "location": "/endpoints/#utility-endpoints", 
            "text": "These endpoints provide you utilities. They do not map 1:1 to entities provided therein, but they are tasked with several higher-level tasks such as communicating the status of the node, providing you with an introduction, or bootstrapping off of a node.   Status", 
            "title": "Utility Endpoints"
        }, 
        {
            "location": "/endpoints/#status", 
            "text": "Endpoint:  /status  GET  Status is how you check whether a node is online, and is not too busy for you to connect. If you receive an 200 from a status, the node is online, and will be able to respond to you. If you receive a 429, the remote node is busy, and you might be better served connecting to some other node for the time being.  There is no body to this request.  POST  If the local nodes provides a Node header, the status endpoint responds with the remote node's Node header. The remote will also save the local to its database for possible future connections.  Filters  Does not support any filters.", 
            "title": "Status"
        }, 
        {
            "location": "/endpoints/#entity-endpoints", 
            "text": "All of the objects in Mim, but not sub-objects, will have their endpoints. For example,  Board  is the endpoint where you query and get board objects. Example request and responses can be found  here .   Boards  Threads  Posts  Votes  Keys  Addresses  TrustStates   Entity GET  If you do a GET on any entity endpoint, you will be given the objects of that endpoint in accordance with the standard results policy. This reply will be coming from a cache. See Usage Examples for the syntax of this reply.  [entity]/index  https://1.2.3.4:34821/v0/boards/index  This endpoint provides you with the list of caches for that endpoint. The remote can provide up to 1000 cache links in the responses section.  Each of the cache responses will be approximately 0.15kb. The base schema is 0.7kb. Therefore, with 10000 caches, the maximum size of this response should be below 5mb.  The remote can also provide more than 10000 cache links without violating the protocol, but if the index response size is larger than what would be required for 1000 caches, the local, at its own discretion, can abort. The reason for this is that anything larger than that has a higher likelihood of a denial of service attack.  In the case you abort the caches index for whatever reason, you can access the last cache (detailed below) to access the last cache, which includes its own link, and the link to the prior cache. You can go backwards by following links one by one.   [entity]/cache_[random_cache_id]/0.json  Example:  https://1.2.3.4:34821/v0/boards/cache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688/0.json  This returns you the first page of the cache you requested. An example of this response is available at the examples session. Each of these pages have the entities you want to have.  [random_cache_id]  is a SHA256 hash of a random string. It has no significance other than being unique and is not stored anywhere.  Example [random_cache_id]:  cache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688  [entity]/cache_[random_cache_id]/index/0.json  This is where the index of this cache is. Each of these indexes will be based the cache, and they consist of index of that entire cache.  Addresses do not have a cache, as the index form of Address is itself.  Filters  No endpoint of the entity GET supports any filters.  Entity POST  POST allows you to query the remote node using filters provided in each endpoint, if any.  You will receive the link of the first page of the pagination that includes your answer. This response will be kept alive for 30 minutes from the time of request, so you should be done downloading all the pages before then. See Usage Examples for the syntax of this reply.", 
            "title": "Entity Endpoints"
        }, 
        {
            "location": "/endpoints/#boards", 
            "text": "Endpoint:  /boards  Provides board objects.  Filters  Supports  timestamp ,  fingerprints  and  embeds . The embeds are these:   Threads  Keys", 
            "title": "Boards"
        }, 
        {
            "location": "/endpoints/#threads", 
            "text": "Endpoint:  /threads  Provides thread objects.  Filters  Supports  timestamp ,  fingerprints  and  embeds . The embeds are these:   Posts  Keys", 
            "title": "Threads"
        }, 
        {
            "location": "/endpoints/#posts", 
            "text": "Endpoint:  /posts  Provides post objects.  Filters  Supports  timestamp ,  fingerprints  and  embeds . The embeds are these:   Keys  Votes", 
            "title": "Posts"
        }, 
        {
            "location": "/endpoints/#votes", 
            "text": "Endpoint:  /votes  Provides vote objects.  Filters  Supports  timestamp ,  fingerprints . Does not support  embeds .", 
            "title": "Votes"
        }, 
        {
            "location": "/endpoints/#keys", 
            "text": "Endpoint:  /keys  Provides key objects.  Filters  Supports  timestamp ,  fingerprints . Does not support  embeds .", 
            "title": "Keys"
        }, 
        {
            "location": "/endpoints/#addressses", 
            "text": "Endpoint:  /addresses  Provides address objects.  Filters  Supports  timestamp ,  fingerprints . Does not support  embeds .", 
            "title": "Addressses"
        }, 
        {
            "location": "/endpoints/#truststates", 
            "text": "Endpoint:  /truststates  Provides trust state objects.  Filters  Supports  timestamp ,  fingerprints  and  embeds . The embeds are these:   Keys", 
            "title": "TrustStates"
        }, 
        {
            "location": "/flows/", 
            "text": "Common Flows\n\n\nMim connections are stateless for the server, so this connection 'lifecycle' is entirely under the control of the asking node. This is not a lifecycle where you application needs to do it this way. This is just the documentation of how Aether, the Mim reference client, does this. If you have different priorities and concerns, your lifecycle should also be different.\n\n\nThe local node is called L. The remote node is called R.\n\n\nBootstrap\n\n\nBootstrap happens when a node joins the network for the first time.\n\n\nBootstrapping is an expensive process for the entire network in terms of bandwidth usage. If you are a node with significant numbers of people bootstrapping off of you, you will be disproportionately affected. To prevent that, bootstrapping process is designed to be soft on any one node. Instead it tries to split the load into the network more equally.\n\n\nBootstrap process does not give the new user the entire history of the network, because that would be too taxing for everyone in the network. What it provides is simply the last 7 days by default, minimum 1000 objects and maximum 10,000 (For more information on the limits, see Standard Results Policy).\n\n\nL is given by the user R1's Address as the bootstrapper, or a bootstrap Address is hardcoded to the installed client.\n\n\n1) L does a POST on the status endpoint of the R1 to determine if the node is available. If it receives a HTTP 200 and the node header, it saves the header as an Address and continues forward. If it receives a HTTP 429 Too Busy, it waits 120 seconds before trying again.\n\n\n2) L does a POST request on the Addresses endpoint with no filters of R1. This gives L all Addresses R is willing to give to L within the \nStandard Results Policy\n.\n\n\nIf the POST request fails (e.g. because R1 is a static node), L does a GET request to the same endpoint.\n\n\n3) L connects to R2 ... R8, the nodes it has received from the bootstrap node, and it asks the latest caches of the entities in the network for the last day, via doing a GET request with cache filter (cache=0).\n\n\nEach node gets an object type, so R2 gets asked, for example, latest cache of boards, R3 latest cache of threads, etc.\n\n\n4) L connects to R9 ... R15 and it asks the latest caches of entities for \nthe day before last day\n (cache=1).\n\n\n5) L repeats this with different nodes until it has 7 days of caches for all endpoints (cache=7). When the node is done, the bootstrap is completed.\n\n\nIn the case there are less addresses that are online than the caches that need to be requested, the process wraps around and R1 gets asked a second time.\n\n\nIntroduction\n\n\nIntroduction happens when a node encounters a node that it previously had not encountered.\n\n\n1) L does a POST on the status endpoint of the R1 to determine if the node is available. If it receives a HTTP 200 and the node header, it saves the header as an Address and continues forward. If it receives a HTTP 429 Too Busy, it waits 120 seconds before trying again.\n\n\n2) L requests index via GET of R.\n\n\n3) L receives the last day's cache, paginated. It goes through the pages and the cache points out to the day before's cache. L goes through all of the caches and their pagination, by default up until it reaches 7 days, or more if the end user has instructed the node to do so.\n\n\n4) L saves the timestamp of index of the most recent cache. This is the point L has synced up to. For L, all 7 endpoints of R now have the same timestamp.\n\n\n5) L does a POST request to index with the timestamp filter. Since this is a POST request, this time, it will not hit the cache, and the result will be the index starting from the timestamp to current.\n\n\n6) L saves the new timestamp. L now has knowledge of all posts that R has from the oldest R is willing to give, to now.\n\n\n7) L goes through the list of fingerprints and creates a list of fingerprints of objects it does not have, and wants. These list of fingerprints are provided with just enough information that L can make a decision on whether it wants them or not.\n\n\n8) For the things that L does not have, L hits the appropriate endpoints with POST requests, filtered by fingerprints. These endpoints will return information that L has requested.\n\n\nSync\n\n\nSync happens when a node encounters a node that it previously encountered and introduced.\n\n\n1) L does a POST on the status endpoint of the R1 to determine if the node is available. If it receives a HTTP 200 and the node header, it saves the header as an Address and continues forward. If it receives a HTTP 429 Too Busy, it waits 120 seconds before trying again.\n\n\nThis is important because L needs to know the Node Id of the R to be able to fetch the timestamps associated with that Node it from its own database.\n\n\n2) L does a POST request on R's index endpoint with a timestamp filter.\n\n\n3) R returns all new and updated entities since the timestamp.\n\n\n4) L determines which fingerprints it wants to request from R. L goes to the appropriate endpoints, and requests the objects via a POST request with a fingerprints filter.", 
            "title": "Common Flows"
        }, 
        {
            "location": "/flows/#common-flows", 
            "text": "Mim connections are stateless for the server, so this connection 'lifecycle' is entirely under the control of the asking node. This is not a lifecycle where you application needs to do it this way. This is just the documentation of how Aether, the Mim reference client, does this. If you have different priorities and concerns, your lifecycle should also be different.  The local node is called L. The remote node is called R.", 
            "title": "Common Flows"
        }, 
        {
            "location": "/flows/#bootstrap", 
            "text": "Bootstrap happens when a node joins the network for the first time.  Bootstrapping is an expensive process for the entire network in terms of bandwidth usage. If you are a node with significant numbers of people bootstrapping off of you, you will be disproportionately affected. To prevent that, bootstrapping process is designed to be soft on any one node. Instead it tries to split the load into the network more equally.  Bootstrap process does not give the new user the entire history of the network, because that would be too taxing for everyone in the network. What it provides is simply the last 7 days by default, minimum 1000 objects and maximum 10,000 (For more information on the limits, see Standard Results Policy).  L is given by the user R1's Address as the bootstrapper, or a bootstrap Address is hardcoded to the installed client.  1) L does a POST on the status endpoint of the R1 to determine if the node is available. If it receives a HTTP 200 and the node header, it saves the header as an Address and continues forward. If it receives a HTTP 429 Too Busy, it waits 120 seconds before trying again.  2) L does a POST request on the Addresses endpoint with no filters of R1. This gives L all Addresses R is willing to give to L within the  Standard Results Policy .  If the POST request fails (e.g. because R1 is a static node), L does a GET request to the same endpoint.  3) L connects to R2 ... R8, the nodes it has received from the bootstrap node, and it asks the latest caches of the entities in the network for the last day, via doing a GET request with cache filter (cache=0).  Each node gets an object type, so R2 gets asked, for example, latest cache of boards, R3 latest cache of threads, etc.  4) L connects to R9 ... R15 and it asks the latest caches of entities for  the day before last day  (cache=1).  5) L repeats this with different nodes until it has 7 days of caches for all endpoints (cache=7). When the node is done, the bootstrap is completed.  In the case there are less addresses that are online than the caches that need to be requested, the process wraps around and R1 gets asked a second time.", 
            "title": "Bootstrap"
        }, 
        {
            "location": "/flows/#introduction", 
            "text": "Introduction happens when a node encounters a node that it previously had not encountered.  1) L does a POST on the status endpoint of the R1 to determine if the node is available. If it receives a HTTP 200 and the node header, it saves the header as an Address and continues forward. If it receives a HTTP 429 Too Busy, it waits 120 seconds before trying again.  2) L requests index via GET of R.  3) L receives the last day's cache, paginated. It goes through the pages and the cache points out to the day before's cache. L goes through all of the caches and their pagination, by default up until it reaches 7 days, or more if the end user has instructed the node to do so.  4) L saves the timestamp of index of the most recent cache. This is the point L has synced up to. For L, all 7 endpoints of R now have the same timestamp.  5) L does a POST request to index with the timestamp filter. Since this is a POST request, this time, it will not hit the cache, and the result will be the index starting from the timestamp to current.  6) L saves the new timestamp. L now has knowledge of all posts that R has from the oldest R is willing to give, to now.  7) L goes through the list of fingerprints and creates a list of fingerprints of objects it does not have, and wants. These list of fingerprints are provided with just enough information that L can make a decision on whether it wants them or not.  8) For the things that L does not have, L hits the appropriate endpoints with POST requests, filtered by fingerprints. These endpoints will return information that L has requested.", 
            "title": "Introduction"
        }, 
        {
            "location": "/flows/#sync", 
            "text": "Sync happens when a node encounters a node that it previously encountered and introduced.  1) L does a POST on the status endpoint of the R1 to determine if the node is available. If it receives a HTTP 200 and the node header, it saves the header as an Address and continues forward. If it receives a HTTP 429 Too Busy, it waits 120 seconds before trying again.  This is important because L needs to know the Node Id of the R to be able to fetch the timestamps associated with that Node it from its own database.  2) L does a POST request on R's index endpoint with a timestamp filter.  3) R returns all new and updated entities since the timestamp.  4) L determines which fingerprints it wants to request from R. L goes to the appropriate endpoints, and requests the objects via a POST request with a fingerprints filter.", 
            "title": "Sync"
        }, 
        {
            "location": "/examples/", 
            "text": "Examples\n\n\nHere you can see examples of GET and POST requests, and GET and POST responses used in Mim for all available endpoints. All endpoints are HTTPS only.\n\n\n\n\nRequests\n\n\nGET\n\n\nPOST\n\n\n\n\n\n\nResponses\n\n\nStatus\n\n\nGET\n\n\nPOST\n\n\n\n\n\n\nIndex\n\n\nGET\n\n\nPOST\n\n\n\n\n\n\nEntity endpoints\n\n\nGET\n\n\nPOST\n\n\n\n\n\n\n\n\n\n\n\n\nRequests\n\n\nGET\n\n\nYou can issue GET requests by just pointing your browser towards that link. These will give you last day's cache in a paginated format, with a link to be able to jump to the cache of the day before, and so on.\n\n\nWithout filters\n\n\nhttps://[ip-address-of-node]:[port]/[protocol-version]/[endpoint]/[page_number]\n\n\nEndpoints\n\n\nThese are all of the endpoints available in the base protocol. Extensions can extend the protocol in a way that can create new endpoints, new objects and new behaviours.\n\n\nhttps://1.2.3.4:34821/v0/status.json\n\n\n\n\n\nhttps://1.2.3.4:34821/v0/boards/index.json\n\n\nhttps://1.2.3.4:34821/v0/threads/index.json\n\n\nhttps://1.2.3.4:34821/v0/posts/index.json\n\n\nhttps://1.2.3.4:34821/v0/votes/index.json\n\n\nhttps://1.2.3.4:34821/v0/keys/index.json\n\n\nhttps://1.2.3.4:34821/v0/addresses/index.json\n\n\nhttps://1.2.3.4:34821/v0/truststates/index.json\n\n\nThe [entity]/index endpoints allow you to reach to the index of the existing caches of that endpoint. From this page, you will be given the list of caches you can reach.\n\n\nReaching out to actual data\n\n\nhttps://localhost:34821/v0/threads/cache_e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855/0.json // page 0 of a cache\n\n\ncache_9843jifnk\n is a random name. It can be generated by however the remote wishes. \n0\n is the first page of that cache. The amount of data are determined by the \nminimum results policy\n.\n\n\nPOST\n\n\nPost requests are usually done to reach non-cached data that is current. (GET requests hit cached data)\n\n\nGeneral format\n\n\nExactly the same endpoints provided above.\n\n\nThe standard POST Request\n\n\n{\n  \nnode_id\n: \ne3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n,\n  \naddress\n: {\n    \nlocation\n: \n, // L should infer from connection\n    \nsublocation\n: \n, // L should infer from connection\n    \nlocation_type\n: 0, // L should infer from connection\n    \nport\n: 23432,\n    \ntype\n: 2,\n    \nlast_online\n: 0, // L should infer from connection\n    \nprotocol\n: {\n      \nversion_major\n: 0,\n      \nversion_minor\n: 1,\n      \nextensions\n: []\n    },\n    \nclient\n: {\n      \nversion_major\n: 2,\n      \nversion_minor\n: 0,\n      \nversion_patch\n: 0,\n      \nname\n: \nAether\n\n    }\n  },\n  \nfilters\n: [\n   // ... (If there are filters being requested)\n  ]\n}\n\n\n\n\nFilters section should receive the filters you want to have. Check the endpoints documentation for available filters for each endpoint.\n\n\nThis all below, excluding filters section,m will be called [[node info]] in this document after this for the sake of brevity.\n\n\nWithout filters\n\n\nIf the filter array is empty, the remote will assume that means a timestamp filter of a week, which is the longest duration you can ask for. When you do a post, you have to have a request body.\n\n\nWith filters\n\n\nThere are three types of filters that you can provide within the POST request body given above.\n\n\n\n\nTimestamp\n\n\nFingerprints\n\n\nEmbeds\n\n\n\n\nTimestamp\n\n\n{\n  // [[node info]]\n  \nfilters\n: [\n    {\n      \ntype\n: \ntimestamp\n,\n      \nvalues\n: 1442039887\n    }\n  ],\n}\n\n\n\n\nFingerprints\n\n\n{\n  // [[node info]]\n  \nfilters\n: [\n    {\n      \ntype\n: \nfingerprint\n,\n      \nvalues\n: [\n      \nbdb237bf8c5de6b60ba1e2dcfe364fc24f583e568d1682f851a9d0f11a45c78d\n,\n      \n421c76d77563afa1914846b010bd164f395bd34c2102e5e99e0cb9cf173c1d87\n,\n      \ne23e44bf8d3adfa1c78d22c13554ffd12002d6ed2a016087d37d3d6f9ab47991\n,\n      \n0f5c0b2e41c7646b11a0e24080ab59e63fd9d21331c99859d5fad7937c1992c9\n\n    ]\n    }\n  ],\n}\n\n\n\n\nEmbeds\n\n\n{\n  // [[node info]]\n  \nfilters\n: [\n    {\n      \ntype\n: \nembed\n,\n      \nvalues\n: [\nthreads\n, \nkeys\n]\n    }\n  ],\n}\n\n\n\n\nResponses\n\n\nStatus\n\n\nExample GET response\n\n\nHTTP 200 OK\n With no body.\n\n\nExample POST response\n\n\n{\n  \nnode_id\n: \ne3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n,\n  \naddress\n: {\n    \nlocation\n: \n, // L should infer from connection\n    \nsublocation\n: \n, // L should infer from connection\n    \nlocation_type\n: 0, // L should infer from connection\n    \nport\n: 23432,\n    \ntype\n: 2,\n    \nlast_online\n: 0, // L should infer from connection\n    \nprotocol\n: {\n      \nversion_major\n: 0,\n      \nversion_minor\n: 1,\n      \nextensions\n: []\n    },\n    \nclient\n: {\n      \nversion_major\n: 2,\n      \nversion_minor\n: 0,\n      \nversion_patch\n: 0,\n      \nname\n: \nAether\n\n    }\n  },\n  \nentity\n: \nstatus\n,\n  \nendpoint\n: \nstatus\n,\n}\n\n\n\n\n\n\n\n\n\n\nThe general format is \nhttps://[node ip]:[node port]/[endpoint]/[response_url]/[page_number]\n\n\nEntity Endpoints\n\n\nExample GET entity index Response\n\n\nExample endpoint: \nhttps://1.2.3.4:34821/v0/[entity]/index\n. Same structure with all [entity]/index endpoints. The items in \nresults\n section are caches with their start and ending dates denoted.\n\n\n{\n  \nnode_id\n: \ne3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n,\n  \naddress\n: {\n    \nlocation\n: \n, // L should infer from connection\n    \nsublocation\n: \n, // L should infer from connection\n    \nlocation_type\n: 0, // L should infer from connection\n    \nport\n: 23432,\n    \ntype\n: 2,\n    \nlast_online\n: 0, // L should infer from connection\n    \nprotocol\n: {\n      \nversion_major\n: 0,\n      \nversion_minor\n: 1,\n      \nextensions\n: []\n    },\n    \nclient\n: {\n      \nversion_major\n: 2,\n      \nversion_minor\n: 0,\n      \nversion_patch\n: 0,\n      \nname\n: \nAether\n\n    }\n  },\n  \nentity\n: \nboards\n,\n  \nendpoint\n: \nentity_index\n,\n  \ntimestamp\n: 1442097755,\n  \nresults\n: [\n    {\n      \nresponse_url\n: \ncache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688\n,\n      \nstarts_from\n: 1000952512,\n      \nends_at\n: 1445197252\n    },\n    {\n      \nresponse_url\n: \ncache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688\n,\n      \nstarts_from\n: 1000952512,\n      \nends_at\n: 1445197252\n    },\n    {\n      \nresponse_url\n: \ncache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688\n,\n      \nstarts_from\n: 1000952512,\n      \nends_at\n: 1445197252\n    },\n    {\n      \nresponse_url\n: \ncache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688\n,\n      \nstarts_from\n: 1000952512,\n      \nends_at\n: 1445197252\n    },\n    {\n      \nresponse_url\n: \ncache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688\n,\n      \nstarts_from\n: 1000952512,\n      \nends_at\n: 1445197252\n    },\n    {\n      \nresponse_url\n: \ncache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688\n,\n      \nstarts_from\n: 1000952512,\n      \nends_at\n: 1445197252\n    },\n    {\n      \nresponse_url\n: \ncache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688\n,\n      \nstarts_from\n: 1000952512,\n      \nends_at\n: 1445197252\n    },\n    {\n      \nresponse_url\n: \ncache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688\n,\n      \nstarts_from\n: 1000952512,\n      \nends_at\n: 1445197252\n    }\n  ]\n}\n\n\n\n\nExample GET cache index response\n\n\nExample endpoint: \n//localhost:8000/posts/cache_0c558847c...7b14/index/0.json\n\n\n{\n    \nnode_id\n: \ne3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n,\n    \naddress\n: {\n        \nlocation\n: \n,\n        \nsublocation\n: \n,\n        \nlocation_type\n: 0,\n        \nport\n: 0,\n        \ntype\n: 2,\n        \nlast_online\n: 0,\n        \nprotocol\n: {\n            \nversion_major\n: 0,\n            \nversion_minor\n: 1,\n            \nextensions\n: []\n        },\n        \nclient\n: {\n            \nversion_major\n: 2,\n            \nversion_minor\n: 0,\n            \nversion_patch\n: 0,\n            \nname\n: \nAether\n\n        }\n    },\n    \nentity\n: \nboards\n,\n    \nendpoint\n: \ncache_index\n,\n    \ntimestamp\n: 1448163764,\n    \nstarts_from\n: 1447814295,\n    \nends_at\n: 1447900695,\n    \npagination\n: {\n        \npages\n: 0,\n        \ncurrent_page\n: 0\n    },\n    \ncaching\n: {\n        \nserved_from_cache\n: true,\n        \ncache_scope\n: \nday\n,\n        \nprev_cache_url\n: \ncache_664b09483da3a122512200656ba707626a330c441ee6ef02506be57eb4047ffa\n,\n        \ncurrent_cache_url\n: \ncache_fa798564efd639282d66a5f8ee6c6171d35633b420a7ffaaf0318748a84e62d1\n\n    },\n    \nresponse\n: [\n        {\n            \nfingerprint\n: \n0221c70a30df591e548b2a13674cb85d9e4be3841c6434cdb0ec6e22b8b1bfc3\n,\n            \ncreation\n: 1439603165,\n            \nlast_update\n: 1447900175\n        },\n        {\n            \nfingerprint\n: \n50b12fb93ebde496b74bf0ef2dbe08639f7d04ecd7a92bf053505b0c8d6de699\n,\n            \ncreation\n: 1439733415,\n            \nlast_update\n: 1447899299\n        },\n        {\n            \nfingerprint\n: \n1c28d1b805bd6c4284d6a6344b5c853454ffd4f79f74ae752b1471cb98e75c47\n,\n            \ncreation\n: 1446817789,\n            \nlast_update\n: 1447899118\n        }\n    ]\n}", 
            "title": "Usage Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "Here you can see examples of GET and POST requests, and GET and POST responses used in Mim for all available endpoints. All endpoints are HTTPS only.   Requests  GET  POST    Responses  Status  GET  POST    Index  GET  POST    Entity endpoints  GET  POST", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#requests", 
            "text": "", 
            "title": "Requests"
        }, 
        {
            "location": "/examples/#get", 
            "text": "You can issue GET requests by just pointing your browser towards that link. These will give you last day's cache in a paginated format, with a link to be able to jump to the cache of the day before, and so on.  Without filters  https://[ip-address-of-node]:[port]/[protocol-version]/[endpoint]/[page_number]  Endpoints  These are all of the endpoints available in the base protocol. Extensions can extend the protocol in a way that can create new endpoints, new objects and new behaviours.  https://1.2.3.4:34821/v0/status.json   https://1.2.3.4:34821/v0/boards/index.json  https://1.2.3.4:34821/v0/threads/index.json  https://1.2.3.4:34821/v0/posts/index.json  https://1.2.3.4:34821/v0/votes/index.json  https://1.2.3.4:34821/v0/keys/index.json  https://1.2.3.4:34821/v0/addresses/index.json  https://1.2.3.4:34821/v0/truststates/index.json  The [entity]/index endpoints allow you to reach to the index of the existing caches of that endpoint. From this page, you will be given the list of caches you can reach.  Reaching out to actual data  https://localhost:34821/v0/threads/cache_e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855/0.json // page 0 of a cache  cache_9843jifnk  is a random name. It can be generated by however the remote wishes.  0  is the first page of that cache. The amount of data are determined by the  minimum results policy .", 
            "title": "GET"
        }, 
        {
            "location": "/examples/#post", 
            "text": "Post requests are usually done to reach non-cached data that is current. (GET requests hit cached data)  General format  Exactly the same endpoints provided above.  The standard POST Request  {\n   node_id :  e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 ,\n   address : {\n     location :  , // L should infer from connection\n     sublocation :  , // L should infer from connection\n     location_type : 0, // L should infer from connection\n     port : 23432,\n     type : 2,\n     last_online : 0, // L should infer from connection\n     protocol : {\n       version_major : 0,\n       version_minor : 1,\n       extensions : []\n    },\n     client : {\n       version_major : 2,\n       version_minor : 0,\n       version_patch : 0,\n       name :  Aether \n    }\n  },\n   filters : [\n   // ... (If there are filters being requested)\n  ]\n}  Filters section should receive the filters you want to have. Check the endpoints documentation for available filters for each endpoint.  This all below, excluding filters section,m will be called [[node info]] in this document after this for the sake of brevity.  Without filters  If the filter array is empty, the remote will assume that means a timestamp filter of a week, which is the longest duration you can ask for. When you do a post, you have to have a request body.  With filters  There are three types of filters that you can provide within the POST request body given above.   Timestamp  Fingerprints  Embeds   Timestamp  {\n  // [[node info]]\n   filters : [\n    {\n       type :  timestamp ,\n       values : 1442039887\n    }\n  ],\n}  Fingerprints  {\n  // [[node info]]\n   filters : [\n    {\n       type :  fingerprint ,\n       values : [\n       bdb237bf8c5de6b60ba1e2dcfe364fc24f583e568d1682f851a9d0f11a45c78d ,\n       421c76d77563afa1914846b010bd164f395bd34c2102e5e99e0cb9cf173c1d87 ,\n       e23e44bf8d3adfa1c78d22c13554ffd12002d6ed2a016087d37d3d6f9ab47991 ,\n       0f5c0b2e41c7646b11a0e24080ab59e63fd9d21331c99859d5fad7937c1992c9 \n    ]\n    }\n  ],\n}  Embeds  {\n  // [[node info]]\n   filters : [\n    {\n       type :  embed ,\n       values : [ threads ,  keys ]\n    }\n  ],\n}", 
            "title": "POST"
        }, 
        {
            "location": "/examples/#responses", 
            "text": "", 
            "title": "Responses"
        }, 
        {
            "location": "/examples/#status", 
            "text": "Example GET response  HTTP 200 OK  With no body.  Example POST response  {\n   node_id :  e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 ,\n   address : {\n     location :  , // L should infer from connection\n     sublocation :  , // L should infer from connection\n     location_type : 0, // L should infer from connection\n     port : 23432,\n     type : 2,\n     last_online : 0, // L should infer from connection\n     protocol : {\n       version_major : 0,\n       version_minor : 1,\n       extensions : []\n    },\n     client : {\n       version_major : 2,\n       version_minor : 0,\n       version_patch : 0,\n       name :  Aether \n    }\n  },\n   entity :  status ,\n   endpoint :  status ,\n}    The general format is  https://[node ip]:[node port]/[endpoint]/[response_url]/[page_number]", 
            "title": "Status"
        }, 
        {
            "location": "/examples/#entity-endpoints", 
            "text": "Example GET entity index Response  Example endpoint:  https://1.2.3.4:34821/v0/[entity]/index . Same structure with all [entity]/index endpoints. The items in  results  section are caches with their start and ending dates denoted.  {\n   node_id :  e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 ,\n   address : {\n     location :  , // L should infer from connection\n     sublocation :  , // L should infer from connection\n     location_type : 0, // L should infer from connection\n     port : 23432,\n     type : 2,\n     last_online : 0, // L should infer from connection\n     protocol : {\n       version_major : 0,\n       version_minor : 1,\n       extensions : []\n    },\n     client : {\n       version_major : 2,\n       version_minor : 0,\n       version_patch : 0,\n       name :  Aether \n    }\n  },\n   entity :  boards ,\n   endpoint :  entity_index ,\n   timestamp : 1442097755,\n   results : [\n    {\n       response_url :  cache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688 ,\n       starts_from : 1000952512,\n       ends_at : 1445197252\n    },\n    {\n       response_url :  cache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688 ,\n       starts_from : 1000952512,\n       ends_at : 1445197252\n    },\n    {\n       response_url :  cache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688 ,\n       starts_from : 1000952512,\n       ends_at : 1445197252\n    },\n    {\n       response_url :  cache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688 ,\n       starts_from : 1000952512,\n       ends_at : 1445197252\n    },\n    {\n       response_url :  cache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688 ,\n       starts_from : 1000952512,\n       ends_at : 1445197252\n    },\n    {\n       response_url :  cache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688 ,\n       starts_from : 1000952512,\n       ends_at : 1445197252\n    },\n    {\n       response_url :  cache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688 ,\n       starts_from : 1000952512,\n       ends_at : 1445197252\n    },\n    {\n       response_url :  cache_55a295c39e222e3f94d82d795654a0fea9bc981cd2ae82d7c7b8d4975aa52688 ,\n       starts_from : 1000952512,\n       ends_at : 1445197252\n    }\n  ]\n}  Example GET cache index response  Example endpoint:  //localhost:8000/posts/cache_0c558847c...7b14/index/0.json  {\n     node_id :  e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 ,\n     address : {\n         location :  ,\n         sublocation :  ,\n         location_type : 0,\n         port : 0,\n         type : 2,\n         last_online : 0,\n         protocol : {\n             version_major : 0,\n             version_minor : 1,\n             extensions : []\n        },\n         client : {\n             version_major : 2,\n             version_minor : 0,\n             version_patch : 0,\n             name :  Aether \n        }\n    },\n     entity :  boards ,\n     endpoint :  cache_index ,\n     timestamp : 1448163764,\n     starts_from : 1447814295,\n     ends_at : 1447900695,\n     pagination : {\n         pages : 0,\n         current_page : 0\n    },\n     caching : {\n         served_from_cache : true,\n         cache_scope :  day ,\n         prev_cache_url :  cache_664b09483da3a122512200656ba707626a330c441ee6ef02506be57eb4047ffa ,\n         current_cache_url :  cache_fa798564efd639282d66a5f8ee6c6171d35633b420a7ffaaf0318748a84e62d1 \n    },\n     response : [\n        {\n             fingerprint :  0221c70a30df591e548b2a13674cb85d9e4be3841c6434cdb0ec6e22b8b1bfc3 ,\n             creation : 1439603165,\n             last_update : 1447900175\n        },\n        {\n             fingerprint :  50b12fb93ebde496b74bf0ef2dbe08639f7d04ecd7a92bf053505b0c8d6de699 ,\n             creation : 1439733415,\n             last_update : 1447899299\n        },\n        {\n             fingerprint :  1c28d1b805bd6c4284d6a6344b5c853454ffd4f79f74ae752b1471cb98e75c47 ,\n             creation : 1446817789,\n             last_update : 1447899118\n        }\n    ]\n}", 
            "title": "Entity Endpoints"
        }, 
        {
            "location": "/faq/", 
            "text": "Frequently Asked Questions\n\n\nWhy does Mim have GET and POST at the same time? Would the protocol not be simpler and more discoverable by browser if it was just GET requests?\n\n\nA couple reasons. The first is that GET requests have a practical URL encoding size limits. If you end up requesting a couple hundred fingerprints, that link is going to be probably longer than what most systems can deal with, so it's not great for compatibility. You could have the filter on the GET request body, but that is a very blurry area of the HTTP spec, and is usually ignored by most HTTP servers.\n\n\nThe second is that GET requests get cached and saved. So there might be somebody saving the URL and hitting a very expensive query on your computer again and again by mistake.\n\n\nThe third is that it's a violation of the HTTP spec to make GET requests trigger a state change in the server. That's POST's job. That is why there are both GET and POST requests available.\n\n\nWhy is assigning license of communicated content to \nCC-BY-SA license\n required to use Mim Protocol?\n\n\nThis is done to protect the developers of the applications that use the Mim protocol. If that was not the case, your application would not be able to know the license of the content you are receiving from the network, and thus it would be unclear on whether it would be allowed to show the content to the end user of your application. By fixing the license to \nCC-BY-SA license\n for all content, your application always knows that it has a right to display the content it receives from the network.\n\n\nThis also allows your end user to freely modify, remix and redistribute the content he or she sees within the terms of the \nCC-BY-SA license\n, fostering a free and open environment.\n\n\nGood to know\n\n\n\n\nIn Mim protocol, most objects are immutable. When they are emitted from a node and started to be distributed, there is no editing, deleting, or changing the object in any other way.\n\n\nSince there is no such thing as delete, it is up to each client to decide how long they want to serve a post, or how long to keep it. For example, Aether, the reference client for Mim, keeps posts for 6 months, and then stops distributing them. It's a balance between storage needs and historical breadth.\n\n\nMim provides no guarantees that the data provided from the remote node is not malformed. Assume no trust on part of other nodes in actually conforming to the protocol. You should always be doing your own checksum to ensure integrity of the entity received.\n\n\nThe underlying protocol is HTTP over TCP. The format of the messages is JSON.\n\n\nYou should ignore the fields and objects you do not know how to read.\n\n\nThe order of field generation in entities should be ProofOfWork (over all except Signature, Fingerprint, anf itself), Signature (over all except Fingerprint, and itself), and finally Fingerprint (over all, except itself).\n\n\nGood to know: an Unicode character is maximum 4 bytes, per RFC 3629.\n\n\nThe protocol only transmits text. You can expand image links inline in your application if you think it's a good security tradeoff to provide image / video or other types of rich media support. However the only actual data that is transmitted over the network is text.\n\n\nAll of the API responses are only available over HTTPS\n\n\nAll of the API responses will be gzipped in transport.", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#frequently-asked-questions", 
            "text": "Why does Mim have GET and POST at the same time? Would the protocol not be simpler and more discoverable by browser if it was just GET requests?  A couple reasons. The first is that GET requests have a practical URL encoding size limits. If you end up requesting a couple hundred fingerprints, that link is going to be probably longer than what most systems can deal with, so it's not great for compatibility. You could have the filter on the GET request body, but that is a very blurry area of the HTTP spec, and is usually ignored by most HTTP servers.  The second is that GET requests get cached and saved. So there might be somebody saving the URL and hitting a very expensive query on your computer again and again by mistake.  The third is that it's a violation of the HTTP spec to make GET requests trigger a state change in the server. That's POST's job. That is why there are both GET and POST requests available.  Why is assigning license of communicated content to  CC-BY-SA license  required to use Mim Protocol?  This is done to protect the developers of the applications that use the Mim protocol. If that was not the case, your application would not be able to know the license of the content you are receiving from the network, and thus it would be unclear on whether it would be allowed to show the content to the end user of your application. By fixing the license to  CC-BY-SA license  for all content, your application always knows that it has a right to display the content it receives from the network.  This also allows your end user to freely modify, remix and redistribute the content he or she sees within the terms of the  CC-BY-SA license , fostering a free and open environment.  Good to know   In Mim protocol, most objects are immutable. When they are emitted from a node and started to be distributed, there is no editing, deleting, or changing the object in any other way.  Since there is no such thing as delete, it is up to each client to decide how long they want to serve a post, or how long to keep it. For example, Aether, the reference client for Mim, keeps posts for 6 months, and then stops distributing them. It's a balance between storage needs and historical breadth.  Mim provides no guarantees that the data provided from the remote node is not malformed. Assume no trust on part of other nodes in actually conforming to the protocol. You should always be doing your own checksum to ensure integrity of the entity received.  The underlying protocol is HTTP over TCP. The format of the messages is JSON.  You should ignore the fields and objects you do not know how to read.  The order of field generation in entities should be ProofOfWork (over all except Signature, Fingerprint, anf itself), Signature (over all except Fingerprint, and itself), and finally Fingerprint (over all, except itself).  Good to know: an Unicode character is maximum 4 bytes, per RFC 3629.  The protocol only transmits text. You can expand image links inline in your application if you think it's a good security tradeoff to provide image / video or other types of rich media support. However the only actual data that is transmitted over the network is text.  All of the API responses are only available over HTTPS  All of the API responses will be gzipped in transport.", 
            "title": "Frequently Asked Questions"
        }, 
        {
            "location": "/about/", 
            "text": "Mim protocol version v0.1.\n\n\nThis is the protocol underlying Aether. Using this document, you can talk to, and interact with all Mim-compatible nodes, which includes all Aether nodes in existence.\n\n\nCopyright 2012-2016 Burak Nehbit. All rights reserved. For the license, please check the appropriate repository.\n\n\nRevisions\n\n\n0.1 DRAFT\n First public documentation of the protocol in draft form. This document is made available so as to enable discussion, and it not ready for use.\n\n\nLicensing\n\n\nMim is an open protocol. To keep the data that traverses the network also free and open, Mim requires all data that is transmitted across Mim protocol to be licensed by \nCC-BY-SA license\n. (\nWhy?\n)\n\n\nIf you build an application that uses the Mim protocol, you are required to:\n\n\na) Provide to your end user the information that your application uses Mim Protocol, (this could be in the licensing / legal notices page of your application)\n\n\nb) Provide a link to Mim Protocol's home page, (this could be in the licensing / legal notices page of your application)\n\n\nc) Inform your user that using this protocol requires all content that is transmitted using it to be to be licensed by \nCC-BY-SA license\n, therefore if an user communicates using Mim protocol via your application, he or she will be assigning the license of his or her communicated work to \nCC-BY-SA license\n.\n\n\nDisclaimer of Warranty\n\n\nTHERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n\nLimitation of Liability\n\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n\n\nInterpretation of the Sections of Disclaimer of Warranty, and Limitation of Liability\n\n\nIf the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program.", 
            "title": "About"
        }, 
        {
            "location": "/about/#revisions", 
            "text": "0.1 DRAFT  First public documentation of the protocol in draft form. This document is made available so as to enable discussion, and it not ready for use.", 
            "title": "Revisions"
        }, 
        {
            "location": "/about/#licensing", 
            "text": "Mim is an open protocol. To keep the data that traverses the network also free and open, Mim requires all data that is transmitted across Mim protocol to be licensed by  CC-BY-SA license . ( Why? )  If you build an application that uses the Mim protocol, you are required to:  a) Provide to your end user the information that your application uses Mim Protocol, (this could be in the licensing / legal notices page of your application)  b) Provide a link to Mim Protocol's home page, (this could be in the licensing / legal notices page of your application)  c) Inform your user that using this protocol requires all content that is transmitted using it to be to be licensed by  CC-BY-SA license , therefore if an user communicates using Mim protocol via your application, he or she will be assigning the license of his or her communicated work to  CC-BY-SA license .  Disclaimer of Warranty  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.  Limitation of Liability  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.  Interpretation of the Sections of Disclaimer of Warranty, and Limitation of Liability  If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program.", 
            "title": "Licensing"
        }
    ]
}